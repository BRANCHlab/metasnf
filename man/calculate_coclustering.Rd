% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coclustering.R
\name{calculate_coclustering}
\alias{calculate_coclustering}
\title{Calculate coclustering data.}
\usage{
calculate_coclustering(subsample_solutions, sol_df, verbose = FALSE)
}
\arguments{
\item{subsample_solutions}{A list of containing cluster solutions from
distinct subsamples of the data. This object is generated by the function
\code{batch_snf_subsamples()}. These solutions should correspond to the ones in
the solutions data frame.}

\item{sol_df}{A solutions data frame. This object is generated by the
function \code{batch_snf()}. The solutions in the solutions data frame should
correspond to those in the subsample solutions.}

\item{verbose}{If TRUE, output time remaining estimates to console.}
}
\value{
A list containing the following components:
\itemize{
\item cocluster_dfs: A list of dataframes, one per cluster solution, that shows
the number of times that every pair of subjects in the original cluster
solution occurred in the same subsample, the number of times that every
pair clustered together in a subsample, and the corresponding fraction
of times that every pair clustered together in a subsample.
\item cocluster_ss_mats: The number of times every pair of subjects occurred
in the same subsample, formatted as a pairwise matrix.
\item cocluster_sc_mats: The number of times every pair of subjects occurred
in the same cluster, formatted as a pairwise matrix.
\item cocluster_cf_mats: The fraction of times every pair of subjects occurred
in the same cluster, formatted as a pairwise matrix.
\item cocluster_summary: Specifically among pairs of subjects that clustered
together in the original full cluster solution, what fraction of those
pairs remained clustered together throughout the subsample solutions. This
information is formatted as a dataframe with one row per cluster solution.
}
}
\description{
Calculate coclustering data.
}
\examples{
# my_dl <- data_list(
#     list(subc_v, "subcortical_volume", "neuroimaging", "continuous"),
#     list(income, "household_income", "demographics", "continuous"),
#     list(pubertal, "pubertal_status", "demographics", "continuous"),
#     uid = "unique_id"
# )
# 
# sc <- snf_config(my_dl, n_solutions = 5, max_k = 40)
# 
# sol_df <- batch_snf(my_dl, sc)
# 
# my_dl_subsamples <- subsample_dl(
#     my_dl,
#     n_subsamples = 20,
#     subsample_fraction = 0.85
# )
# 
# batch_subsample_results <- batch_snf_subsamples(
#     my_dl_subsamples,
#     sc,
#     verbose = TRUE
# )
# 
# subsample_cluster_solutions <- batch_subsample_results[["cluster_solutions"]]
# 
# pairwise_aris <- subsample_pairwise_aris(
#     subsample_cluster_solutions,
#     return_raw_aris = TRUE,
#     verbose = TRUE
# )
# 
# coclustering_results <- calculate_coclustering(
#     subsample_cluster_solutions,
#     sol_df,
#     verbose = TRUE
# )
# 
# coclustering_results$"cocluster_summary"
# 
# cocluster_dfs <- coclustering_results$"cocluster_dfs"
# 
# cocluster_density(cocluster_dfs[[1]])
# 
# cocluster_heatmap(
#     cocluster_dfs[[1]],
#     dl = my_dl,
#     top_hm = list(
#         "Income" = "household_income",
#         "Pubertal Status" = "pubertal_status"
#     ),
#     annotation_colours = list(
#         "Pubertal Status" = colour_scale(
#             c(1, 4),
#             min_colour = "black",
#             max_colour = "purple"
#         ),
#         "Income" = colour_scale(
#             c(0, 4),
#             min_colour = "black",
#             max_colour = "red"
#         )
#     )
# )
}

devtools::load_all()
library(sloop)
library(testthat)

dl <- data_list(
    list(subc_v, "scv", "neuroimaging", "continuous"),
    list(cort_t, "cort_t", "neuroimaging", "continuous"),
    list(cort_sa, "cort_sa", "neuroimaging", "continuous"),
    list(income, "income", "neuroimaging", "continuous"),
    uid = "unique_id"
)

set.seed(44)
config <- snf_config(dl, n_solutions = 3)
sdf <- config$"settings_df"

solutions_matrix <- batch_snf(dl, sdf, verbose = TRUE)

solutions_matrix2 <- batch_snf2(dl, config, verbose = TRUE)

solutions_matrix3 <- batch_snf2(dl, config, verbose = TRUE, processes = 2)

mapply(sdf)

undebug(batch_snf2)

get_cluster_solutions(solutions_matrix)
get_cluster_solutions(solutions_matrix2)

identical(solutions_matrix, data.frame(solutions_matrix2))


# in: sc, dl
# out: fused matrix, clustering results



#' Run variations of SNF.
#'
#' This is the core function of the metasnf package. Using the information
#' stored in a settings_df (see ?settings_df) and a data list
#' (see ?data_list), run repeated complete SNF pipelines to generate
#' a broad space of post-SNF cluster solutions.
#'
#' @param dl A nested list of input data from `data_list()`.
#' @param sdf A data.frame where each row completely defines an SNF
#'  pipeline transforming individual input dataframes into a final cluster
#'  solution. See ?settings_df or
#'  https://branchlab.github.io/metasnf/articles/settings_df.html for more
#'  details.
#' @param processes Specify number of processes used to complete SNF iterations
#'  * `1` (default) Sequential processing: function will iterate through the
#'    `settings_df` one row at a time with a for loop. This option will
#'     not make use of multiple CPU cores, but will show a progress bar.
#'  * `2` or higher: Parallel processing will use the
#'    `future.apply::future_apply` to distribute the SNF iterations across
#'    the specified number of CPU cores. If higher than the number of
#'    available cores, a warning will be raised and the maximum number of
#'    cores will be used.
#'  * `max`: All available cores will be used.
#' @param return_similarity_matrices If TRUE, function will return a list where
#'  the first element is the solutions matrix and the second element is a list
#'  of similarity matrices for each row in the solutions_matrix. Default FALSE.
#' @param similarity_matrix_dir If specified, this directory will be used to
#'  save all generated similarity matrices.
#' @param verbose If TRUE, output time remaining estimates to console.
#' @return By default, returns a solutions matrix (class "data.frame"), a 
#'  a data frame containing one row for every row of the provided settings
#'  matrix, all the original columns of that settings matrix, and new columns
#'  containing the assigned cluster of each observation from the cluster
#'  solution derived by that row's settings. If `return_similarity_matrices` is
#'  TRUE, the function will instead return a list containing the
#'  solutions matrix as well as a list of the final similarity matrices (class
#'  "matrix") generated by SNF for each row of the settings matrix. If 
#'  `suppress_clustering` is TRUE, the solutions matrix will not be returned
#'  in the output.
#' @export
batch_snf2 <- function(dl,
                       sc,
                       processes = 1,
                       return_similarity_matrices = FALSE,
                       similarity_matrix_dir = NULL,
                       verbose = FALSE) {
    # progress timer
    if (verbose) {
        start <- proc.time() # final time taken for entire function
        remaining_seconds_vector <- vector() # estimate time to completion
    }
    if (!inherits(sc, "snf_config")) {
        metasnf_error("`sc` must be a `snf_config` class object.")
    }
    sdf <- sc$"settings_df"
    wm <- sc$"weights_matrix"
    dfl <- sc$"dist_fns_list"
    cfl <- sc$"clust_fns_list"
    #--------------------------------------------------------------------------
    # Ensure max k smaller than n
    max_k <- max(sdf$"k")
    n_observations <- attributes(dl)$"n_observations"
    # Ensure that the maximum k value doesn't exceed the number of subjects
    if (max_k >= n_observations) {
        metasnf_error(
            "Maximum k ({max_k}) cannot exceed number of ({n_observations})."
        )
    }
    #--------------------------------------------------------------------------
    # 5. Prep weights matrix
    if (is.null(wm)) {
        wm <- weights_matrix(dl, n_solutions = nrow(sdf))
    }
    if (nrow(wm) != nrow(sdf)) {
        metasnf_error(
            "weights_matrix and settings_df should have equal numbers of rows."
        )
    }
    #--------------------------------------------------------------------------
    # Prep clustering functions list
    if (is.null(cfl)) {
        cfl <- clust_fns_list(use_default_clust_fns = TRUE)
    }
    if (max(sdf$"clust_alg") > length(cfl)) {
        metasnf_error(
            "Largest clustering algorithm specified in settings data frame (",
            max(sdf$"clust_alg"), ") exceeds length of clustering functions",
            " list (", length(cfl), ")."
        )
    }
    ###########################################################################
    ## 7. Call separate function for parallel processing
    #if (processes != 1) {
    #    available_cores <- max(future::availableCores())
    #    # Use all available cores
    #    if (processes == "max") {
    #        solutions_matrix <- parallel_batch_snf2(
    #            dl = dl,
    #            dfl = dfl,
    #            cfl = cfl,
    #            sdf = sdf,
    #            wm = wm,
    #            similarity_matrix_dir = similarity_matrix_dir,
    #            return_similarity_matrices = return_similarity_matrices,
    #            processes = available_cores
    #        )
    #        solutions_matrix <- as_settings_df(solutions_matrix)
    #        return(solutions_matrix)
    #    } else if (is.numeric(processes)) {
    #        # Use the user-specified number of cores
    #        if (processes > available_cores) {
    #            metasnf_warning(
    #                "You specified ", processes, " processes, but only ",
    #                available_cores, " cores are available. Defaulting to ",
    #                available_cores, " processes."
    #            )
    #            processes <- available_cores
    #        }
    #        solutions_matrix <- parallel_batch_snf2(
    #            dl = dl,
    #            dfl = dfl,
    #            cfl = cfl,
    #            sdf = sdf,
    #            wm = wm,
    #            similarity_matrix_dir = similarity_matrix_dir,
    #            return_similarity_matrices = return_similarity_matrices,
    #            processes = processes
    #        )
    #        solutions_matrix <- as_settings_df(solutions_matrix)
    #        return(solutions_matrix)
    #    } else {
    #        metasnf_error("Invalid number of processes specified.")
    #    }
    #}
    if (processes > 1) {
        future::plan(future::multisession, workers = processes) 
        prog <- progressr::progressor(steps = nrow(sdf))
        future::plan(future::sequential)
    }
    ###########################################################################
    # 8. Single thread - Create solutions_matrix
    solutions_matrix <- sdf
    sol_mat <- matrix(nrow = attributes(dl)$"n_observations", ncol = nrow(sdf))
    rownames(sol_mat) <- attributes(dl)$"uids"
    ###########################################################################
    # 9. Creation of list to store similarity matrices (if requested)
    similarity_matrices <- list()
    ###########################################################################
    # 10. Iterate through the rows of the settings matrix
    for (i in seq_len(nrow(sdf))) {
        start_time <- Sys.time() # used to estimate time to completion
        sdf_row <- sdf[i, , drop = FALSE]
        # SNF
        fused_network <- snf_step(
            dl = drop_inputs(sdf_row, dl),
            scheme = sdf_row$"snf_scheme",
            k = sdf_row$"k",
            alpha = sdf_row$"alpha",
            t = sdf_row$"t",
            cnt_dist_fn = dfl$"cnt_dist_fns"[[sdf_row$"cnt_dist"]],
            dsc_dist_fn = dfl$"dsc_dist_fns"[[sdf_row$"dsc_dist"]],
            ord_dist_fn = dfl$"ord_dist_fns"[[sdf_row$"ord_dist"]],
            cat_dist_fn = dfl$"cat_dist_fns"[[sdf_row$"cat_dist"]],
            mix_dist_fn = dfl$"mix_dist_fns"[[sdf_row$"mix_dist"]],
            weights_row = wm[i, , drop = FALSE]
        )
        # If user provided a path to save the similarity matrices, save them
        if (!is.null(similarity_matrix_dir)) {
            utils::write.csv(
                x = fused_network,
                file = similarity_matrix_path(similarity_matrix_dir, i),
                row.names = TRUE
            )
        }
        # If the user requested all similarity matrices are returned, add to list
        if (return_similarity_matrices) {
            similarity_matrices[[length(similarity_matrices) + 1]] <- fused_network
        }
        #######################################################################
        # 11. Clustering of the final fused network
        clust_alg <- cfl[[sdf_row$"clust_alg"]]
        cluster_results <- clust_alg(fused_network)
        solution <- cluster_results$"solution"
        sol_mat[, i] <- cluster_results$"solution"
        nclust <- cluster_results$"nclust"
        # Update the solutions_matrix
        solutions_matrix[i, "nclust"] <- nclust
        solutions_matrix[i, rownames(fused_network)] <- solution
        #######################################################################
        # 12. Output progress
        if (verbose) {
            cat("Processing row: ", i, "/", nrow(sdf), "\n", sep = "")
        }
    }
    ###########################################################################
    # 13. Format the final solutions_matrix to be numeric where possible
    ###########################################################################
    # 14. Return output
    if (isTRUE(return_similarity_matrices)) {
        check_similarity_matrices(similarity_matrices)
        batch_snf_results <- list(
            #as_settings_df(solutions_matrix),
            sol_mat,
            similarity_matrices
        )
        names(batch_snf_results) <- c(
            "solutions_matrix",
            "similarity_matrices"
        )
        return(batch_snf_results)
    } else {
        #return(as_settings_df(solutions_matrix))
        return(sol_mat)
    }
}

parallel_batch_snf2 <- function(dl,
                                dfl,
                                cfl,
                                sdf,
                                wm,
                                similarity_matrix_dir,
                                return_similarity_matrices,
                                processes) {
    future::plan(future::multisession, workers = processes)
    ############################################################################
    settings_and_weights_df <- cbind(sdf, wm)
    prog <- progressr::progressor(steps = nrow(sdf))
    # HERE I AM - check out future mapply!
    batch_snf_results <- future.apply::future_mapply(
        settings_and_weights_df,
        1,
        batch_snf
    )
    ############################################################################
    future::plan(future::sequential)
    if (return_similarity_matrices) {
        solutions_matrix_rows <- batch_snf_results |>
            lapply(
                function(x) {
                    x$"solutions_matrix_row"
                }
            )
        solutions_matrix <- data.frame(do.call("rbind", solutions_matrix_rows))
        solutions_matrix <- numcol_to_numeric(solutions_matrix)
        similarity_matrices <- batch_snf_results |>
            lapply(
                function(x) {
                    x$"similarity_matrix"
                }
            )
        batch_snf_results <- list(
            "solutions_matrix" = solutions_matrix,
            "similarity_matrices" = similarity_matrices
        )
        return(batch_snf_results)
    } else {
        solutions_matrix <- data.frame(do.call("rbind", batch_snf_results))
        solutions_matrix <- numcol_to_numeric(solutions_matrix)
        return(solutions_matrix)
    }
}

batch_row_closure2 <- function(dl,
                               dfl,
                               cfl,
                               sdf,
                               wm,
                               similarity_matrix_dir,
                               return_similarity_matrices,
                               prog) {
    sdf_names <- colnames(sdf)
    wm_names <- colnames(wm)
    row_function <- function(settings_and_weights_row) {
        prog()
        settings_and_weights_row_df <- data.frame(t(settings_and_weights_row))
        sdf_row <- settings_and_weights_row_df[, sdf_names] |>
            as_settings_df()
        weights_row <- settings_and_weights_row_df[, wm_names]
        # Reduce data list
        current_dl <- drop_inputs(sdf_row, dl)
        # Extract parameters for snf_step
        current_snf_scheme <- dplyr::case_when(
            sdf_row$"snf_scheme" == 1 ~ "individual",
            sdf_row$"snf_scheme" == 2 ~ "domain",
            sdf_row$"snf_scheme" == 3 ~ "twostep",
        )
        k <- sdf_row$"k"
        alpha <- sdf_row$"alpha"
        t <- sdf_row$"t"
        cnt_dist <- sdf_row$"cnt_dist"
        dsc_dist <- sdf_row$"dsc_dist"
        ord_dist <- sdf_row$"ord_dist"
        cat_dist <- sdf_row$"cat_dist"
        mix_dist <- sdf_row$"mix_dist"
        cnt_dist_fn <- dfl$"cnt_dist_fns"[[cnt_dist]]
        dsc_dist_fn <- dfl$"dsc_dist_fns"[[dsc_dist]]
        ord_dist_fn <- dfl$"ord_dist_fns"[[ord_dist]]
        cat_dist_fn <- dfl$"cat_dist_fns"[[cat_dist]]
        mix_dist_fn <- dfl$"mix_dist_fns"[[mix_dist]]
        # Integrate data
        fused_network <- snf_step(
            current_dl,
            current_snf_scheme,
            k = k,
            alpha = alpha,
            t = t,
            cnt_dist_fn = cnt_dist_fn,
            dsc_dist_fn = dsc_dist_fn,
            ord_dist_fn = ord_dist_fn,
            cat_dist_fn = cat_dist_fn,
            mix_dist_fn = mix_dist_fn,
            weights_row = weights_row
        )
        # Write similarity matrices if requested
        if (!is.null(similarity_matrix_dir)) {
            row_id <- sdf_row$"row_id"
            utils::write.csv(
                x = fused_network,
                file = similarity_matrix_path(similarity_matrix_dir, row_id),
                row.names = TRUE
            )
        }
        clust_alg <- cfl[[sdf_row$"clust_alg"]]
        # cluster_results is a named list containing the cluster solution
        #  (vector of which cluster each patient was assigned to) and the
        #  number of clusters for that solution
        cluster_results <- clust_alg(fused_network)
        solution <- cluster_results$"solution"
        nclust <- cluster_results$"nclust"
        solutions_matrix_row <- sdf_row
        solutions_matrix_row$"nclust" <- nclust
        solutions_matrix_row[1, rownames(fused_network)] <- solution
        if (return_similarity_matrices) {
            batch_snf_results <- list(
                "solutions_matrix_row" = solutions_matrix_row,
                "similarity_matrix" = fused_network
            )
            return(batch_snf_results)
        } else {
            return(solutions_matrix_row)
        }
    }
    return(row_function)
}

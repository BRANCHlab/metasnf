---
title: "Correlation and Plotting"
output:
    rmarkdown::html_vignette:
        toc: true
vignette: >
  %\VignetteIndexEntry{Correlation and Plotting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In heterogeneous diseases such as childhood asthma, you can have many predictor datasets that feed into SNF integration and many outcome variable you wish to visualize.
Not to mention outcomes are also heterogeneous.
Often times a diagnosis is made based on a variety of clinical symptoms and tests.
In this case, SNF integration needs to get more organized.
Some terminology used in this document with respect to heterogeneous disease:

- features/predictor features = a single feature such as `Asthma_mother`

- dataset = comprised of multiple features. Example: a group of features `Asthma_mother`, `Wheeze_mother`, `Asthma_father`, `Wheeze_father` that make up of `parental_asthma` **dataset**

- datatype = Multiple datasets get feed into a datatype-specific SNF integration, after which this whole group is called datetype. Example: `parental_indication` **datatype** that comprised of `parental_asthma` and `genetic_risk_score`



## Part 1 - Using output similarity matrix and cluster assignment to plot heatmap
In alternative to the simple heatmap SNFtool provides, now you can plot using plotting features from the fancy ComplexHeatmp. Using the sample data from SNFtool:

original chunk:

```{r}
library(metasnf)
library(SNFtool)
data(Data1) # 200 samples
data(Data2) # 200 samples

dist1 <- as.matrix(dist(Data1))
dist2 <- as.matrix(dist(Data2))

W1 <- affinityMatrix(dist1, K = 20, sigma = 0.5)
W2 <- affinityMatrix(dist2, K = 20, sigma = 0.5)

W = SNF(list(W1,W2), 20, 20)
group_cluster = spectralClustering(W, K = 3)

displayClustersHeatmap(W, group_cluster)



min(W)
max(W)
```

replacement chunk:

```{r}

# Load in data from SNFtool
data(Data1)
data(Data2)

# Assign unique patient identifiers to each patient
Data1$"patient_id" <- 101:(nrow(Data1) + 100)
Data2$"patient_id" <- 101:(nrow(Data2) + 100)

# Generate data_list
data_list <- generate_data_list(
    list(Data1, "genes_1_and_2_exp", "gene_expression", "continuous"),
    list(Data2, "genes_1_and_2_meth", "gene_methylation", "continuous"),
    uid = "patient_id"
)

# Generate settings_matrix
settings_matrix <- generate_settings_matrix(
    data_list,
    nrow = 1,
    max_k = 40,
    seed = 42
)

# Run SNF and clustering
batch_snf_results <- batch_snf(
    data_list,
    settings_matrix,
    return_similarity_matrices = TRUE
)

solutions_matrix <- batch_snf_results$"solutions_matrix"
similarity_matrices <- batch_snf_results$"similarity_matrices"

# The first (and only) similarity matrix:
similarity_matrix <- similarity_matrices[[1]]

# Rescale the diagonals to have the mean value of the off-diagonals. Reduces
#  contrast during plotting.
scaled_sim <- scale_diagonals(similarity_matrix, method = "mean")

max(scaled_sim)
min(scaled_sim)

# The first (and only) cluster solution:
cluster_solution <- get_cluster_solutions(solutions_matrix)$"1"

displayClustersHeatmap(scaled_sim, cluster_solution)

max(scaled_sim) # 0.05166172
min(scaled_sim) # 0.0002163452
```

Most of the times it is ok to ignore the warning message after checking for outliers in your data.For similarity matrices it almost always has outliers since identical sample having too large a value (for example 0.5). Use `suppressMessages(displayClustersHeatmap(W, group_cluster))` to suppress the message.

Of course you can add annotation. Say I want to display sex annotation on the left, outcome annotations for asthma diagnosis and atopic asthma at the top (for simplicity here let's stick to 2 outcomes):
```{r}
# Set the possible values
gender <- c("female", "male")
diagnosis <- c("definite asthma", "possible asthma", "no asthma")
atopic_asthma <- c("Yes", "No")

# Generate 200 random values
random_genders <- sample(gender, 200, replace = TRUE)
random_diagnosis <- sample(diagnosis, 200, replace = TRUE)
random_allergy_asthma <- sample(atopic_asthma, 200, replace = TRUE)

# set "row" annotation (with respect to heatmap) to display on the left side
row_ha = ComplexHeatmap::rowAnnotation(Sex = random_genders,
                                       col = list(Sex = c("female" = "pink1",
                                                          "male" = "skyblue1")),
                                       show_legend = c(TRUE)
                                                  )
# top annotation
top_ha = ComplexHeatmap::HeatmapAnnotation(Diagnosis = random_diagnosis,
                                           Atopic_Asthma = random_allergy_asthma,
                                       col = list(Diagnosis = c("definite asthma" = "red3",
                                                          "possible asthma" = "pink1",
                                                          "no asthma" = "bisque1"),
                                                  Atopic_Asthma = c("Yes" = "red3",
                                                                    "No" = "lightgreen")),
                                       show_legend = c(TRUE)
                                                  )

suppressMessages(displayClustersHeatmap(W, group_cluster,
                                        left_annotation = row_ha,
                                        top_annotation = top_ha))
```

Curious to see how cluster assignment of samples segregate in different number of clusters? Now you can plot **Alluvial Plot** from a minimum of 2 clusters to a user-defined max number of clusters easily

```{r}
cluster_file = output_cluster_file(W, numc=6)
head(cluster_file)
```

If you are familiar with alluvial plots and would like to create your own alluvial illustration. `prepare_for_alluvial_wDiagnosis` function generates a "category frequency" dataframe in wide format that you can use to create your own customized plot. Otherwise, we have ` plotClustersAlluvial_wDiagnosis` to conveniently plot alluvial colored by desired outcome variable.

```{r}
# Let's generate some example outcome variables added to cluster_file
cluster_file$Wheeze_status = c(rep("Yes", 20), rep("Sometimes", 60), rep("No", 120))

alluvial_df <- prepare_for_alluvial_wDiagnosis(cluster_file,
                                fill_alluvium_by = "Wheeze_status",
                                numc=6)
alluvial_df
```


```{r}
# this function assumes outcome variables to be in a separate dataframe, with sampleIDs in "Subject_Number" column
# Let's generate some outcome variables
df_outcomes = data.frame(Subject_Number = as.character(rownames(cluster_file)),
                         Wheeze_status = c(rep("Yes", 20), rep("Sometimes", 60), rep("No", 120)))

plotClustersAlluvial_wDiagnosis(W=W,
                                df_env = df_outcomes,
                                numc=6,
                                outcome = "Wheeze_status" )
```

`Wheeze status` may be just one of the many outcomes that is part of asthma diagnosis. In heterogeneous diseases, "Asthma_Diagnosis" is the ultimate outcome. To display it alongside `Wheeze status`:
```{r}
df_outcomes$Asthma_Diagnosis = c(rep("Definite Asthma", 10),
                                 rep("Possible Asthma", 50),
                                 rep("No Asthma", 140))

plotClustersAlluvial_wDiagnosis(W=W,
                                df_env = df_outcomes,
                                numc=6,
                                outcome = "Wheeze_status",
                                key_outcome = "Asthma_Diagnosis")
```


### Part2 - Calculate and display associations between clusters and outcomes

In downstream data analysis for heterogeneous disease, it is often hard to see clear cluster separation by outcome with heatmap due to the large amount of datatypes/predictive features not capturing the entireity of disease. For example, an integration could integrate datatype `blood`:

- white blood cell count at 1 year of age (10 features)

- white blood cell count at 5 year of age (10 features)

Another integration could integrate datatype `Gut_microbiome`

- gut microbial species relative abundances at 3 month of age (300 features)

- gut microbial species relative abundances at 1 year of age (350 features)


and not provding clear indication to asthma diagnosis. However there could still be cluster assignment that associates with your outcome-of-interest.

In this case, we want to find which integration cluster result (thus dataset(s) used for that integration) show significant association to outcomes-of-interest and display with Manhattan plot.

As of now this function does not recognize data type (categorical or continuous) automatically, so we recommend running categorical outcomes and continuous outcomes separately. Let's assume the matrix `W` is an integration of the two datasets from `blood` datatype
```{r}
outcomes = c('Asthma_Diagnosis','Atopic_Asthma')

# have a column for sampleID. Make sure cluster column is also in df
df_blood = data.frame(sampleID = seq(1:200),
                cluster = group_cluster,
                Asthma_Diagnosis = random_diagnosis,
                Atopic_Asthma = random_allergy_asthma)
df_blood

outcomes = c('Asthma_Diagnosis','Atopic_Asthma')

# because both outcomes are categorical, we use chi-squared test. Assume the input data has 200 samples
output = clusterToOutcomeCorr(df_blood, outcomes = outcomes, method = "chi-squared", datatype = "blood", size = 200)
output
```


You can keep adding more data/row by running this function again and again, with appropriate test method. Let's add a continuous outcome for lung function `Pre_FEV1_zscore`

```{r}
set.seed(100)
# again, randomly generate some numbers
df_blood$Pre_FEV1_zscore = runif(200)

outcomes = c("Pre_FEV1_zscore")
output = rbind(output, clusterToOutcomeCorr(df_blood, outcomes = outcomes, method = "kruskal", datatype = "blood", size = 200))
output
```

Let's have another matrix for `Gut_microbiome` integration datatype and add some more data for cluster-outcome association tests
```{r}
set.seed(100)
# lets say there are 150 samples. Generate a random number matrix for gut_microbiome integration
W_gut1 <- matrix(runif(300 * 300), nrow = 300, ncol = 300)
W_gut2 <- matrix(runif(300 * 300), nrow = 300, ncol = 300)
W_gut = SNF(list(W_gut1,W_gut2), 20, 20)

# let's say we go with 4 clusters for gut datatype, you can decide your optimal cluster number
group_cluster_gut = spectralClustering(W_gut, K = 4)

# generate table with outcomes in
df_gut = data.frame(sampleID = seq(1:300),
                cluster = group_cluster_gut,
                Asthma_Diagnosis = sample(diagnosis, 300, replace = TRUE),
                Atopic_Asthma = sample(atopic_asthma, 300, replace = TRUE))

# same as before, add categorical outcomes
outcomes = c('Asthma_Diagnosis','Atopic_Asthma')
output = rbind(output, clusterToOutcomeCorr(df_gut, outcomes = outcomes, method = "chi-squared", datatype = "gut_microbiome", size = 300))
output

# add continuous outcome
df_gut$Pre_FEV1_zscore = runif(300)
outcomes = c("Pre_FEV1_zscore")
output = rbind(output, clusterToOutcomeCorr(df_gut, outcomes = outcomes, method = "kruskal", datatype = "gut_microbiome", size = 300))
output

```


Next we can feed this dataframe to plot manhanttan using `clusterToOutcomeManhattan`
```{r}
clusterToOutcomeManhattan(output)
```

The red dotted line represent p-value of 0.05 cutoff. The black dotted line represent the 0.05 cutoff divided by the number of data types which act as a multiple comparison correction.

### Part 3 - correlation heatmap
If we are to look at predictor-predictor or outcome-outcome correlation, we can plot the correlation heatmap using, again, ComplexHeatmap. Make sure you provide the p-values from correlation tests

```{r}
# generate a mock correlation table
corr_predictor <- matrix(runif(50 * 50), nrow = 50, ncol = 50)
rownames(corr_predictor) = seq(1:50)
colnames(corr_predictor) = seq(1:50)

# color by data types (optional). Say first 25 outcomes are from blood datatype, the next 25 from gut_microbiome datatype
labels <- c("Blood",
            "Gut_microbiome")
color = c(rep("#cd34b5", 25),
          rep("goldenrod4", 25))

corrHeatmap(corr_predictor, labels_color = color, row_km=4, column_km = 4)

```

Next let's generate heatmap legend. This function as of now will output legend to a file
```{r}
labels_color = c("#cd34b5", "goldenrod4")

corrHeatmap_legend("test_func.png",
                   labels = labels,
                   labels_color = labels_color)

```


### Part 4 Manhattan plot of correlation to one key outcome

We can also plot correlation of features to **one** user-specified outcome in Manhattan. This is useful if you are doing abSNF where correlation of features to **one** outcome is pre-calculated and you want to see the correlation. The more correlated feature indicates more up-weighing in abSNF.

*Note: abSNF = Association-signal-annotation Boosted Similarity Network Fusion

Similar to running `clusterToOutcomeCorr`, here we have pre-calculated correlation p-value between each predictive feature to "Asthma_Diagnosis". For convenience let's generate some numbers

```{r}
#'  "p.value": from correlation test,
#'  "n": number of samples,
#'  "Group": datatype name,
#'  "Group_index": sequence of datatypes to be displayed
#'
predictor_df = data.frame(
                p.value = c(0.002, 0.03,
                            0.01, 0.09, 0.02, 0.085),
                n = c(200, 100,
                      150, 70, 45, 80),
                Group = c(rep("home environment 3m", 2), rep("parental status", 4)),
                Group_Index = c(rep(1, 2), rep(2,4))
  )
rownames(predictor_df) = c("home_DEP_3m", "home_DNBP_3m",
                "Asthma_mother",
                "Asthma_father",
                "Wheeze_mother",
                "Wheeze_father"

  )
predictor_df

# set dataset labels
labels = c("home environment 3m", "parental status")

CorrManhattan(predictor_df, outcome = "Asthma Diagnosis", dataset_label = labels)
```

The red line represents p-value at 0.05. Now you can see which dataset has features (dots) more associated to asthma outcome.

---
title: "Visualizations"
output:
    rmarkdown::html_vignette:
        toc: true
vignette: >
  %\VignetteIndexEntry{Visualizations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This vignette walks through this package's available plotting functions.

In heterogeneous diseases such as childhood asthma, you can have many predictor datasets that feed into SNF integration and many outcome variable you wish to visualize.
Not to mention outcomes are also heterogeneous.
Often times a diagnosis is made based on a variety of clinical symptoms and tests.
Some terminology used in this document with respect to heterogeneous disease:

- features/predictor features = a single feature such as `Asthma_mother`
- dataset = comprised of multiple features. Example: a group of features `Asthma_mother`, `Wheeze_mother`, `Asthma_father`, `Wheeze_father` that make up of `parental_asthma` **dataset**
- datatype = Multiple datasets get feed into a datatype-specific SNF integration, after which this whole group is called datetype. Example: `parental_indication` **datatype** that comprised of `parental_asthma` and `genetic_risk_score`

## Data set-up

Mock data setup is below.
This example currently makes use of the mock "Data1" and "Data2" objects that are made available by loading the SNFtool package.

```{r}
library(SNFtool)
library(metasnf)

# Load in data from SNFtool
data(Data1)
data(Data2)
```

By default, these two objects are sorted such that the first 100 patients were drawn from one distribution and the second set of 100 patients were drawn from another.
We'll extend this data with some fake additional associations.
The first 100 patients (who come from one cluster) will be more likely to be females with a higher chance of having a definite positive asthma diagnosis and of having atopic asthma than the second set of 100 patients.

```{r}

# Set the possible values
gender <- c("female", "male")
diagnosis <- c("definite asthma", "possible asthma", "no asthma")
atopic_asthma <- c("Yes", "No")

# C1: mostly F, mostly "definite asthma", mostly "Yes" to atopic asthma
c1_genders <- sample(gender, 100, replace = TRUE, prob = c(3, 1))
c1_diagnosis <- sample(diagnosis, 100, replace = TRUE, prob = c(3, 2, 1))
c1_asthma <- sample(atopic_asthma, 100, replace = TRUE, prob = c(3, 1))
c1_ages <- sample(c(12:18), 100, replace = TRUE, prob = c(1:7))

c2_genders <- sample(gender, 100, replace = TRUE, prob = c(1, 3))
c2_diagnosis <- sample(diagnosis, 100, replace = TRUE, prob = c(1, 2, 3))
c2_asthma <- sample(atopic_asthma, 100, replace = TRUE, prob = c(1, 3))
c2_ages <- sample(c(18:30), 100, replace = TRUE,)

genders <- c(c1_genders, c2_genders)
diagnoses <- c(c1_diagnosis, c2_diagnosis)
asthmas <- c(c1_asthma, c2_asthma)
ages <- c(c1_ages, c2_ages)

additional_data <- data.frame(
    gender = genders,
    diagnosis = diagnoses,
    asthma = asthmas,
    age = ages
)

additional_data
```

The patient unique IDs are randomly shuffled in this example to replicate scenarios where the original data doesn't begin ordered by the true cluster labels.

```{r}

# Assign unique patient identifiers to each patient
set.seed(42)
random_ids <- sample(100:999)[1:200]

Data1$"patient_id" <- random_ids
Data2$"patient_id" <- random_ids
additional_data$"patient_id" <- random_ids

```

Then the subtyping and clustering proceeds as shown in previous vignettes.

```{r}

# Generate data_list
data_list <- generate_data_list(
    list(Data1, "genes_1_and_2_exp", "gene_expression", "continuous"),
    list(Data2, "genes_1_and_2_meth", "gene_methylation", "continuous"),
    list(additional_data, "additional_data", "miscellaneous", "mixed"),
    uid = "patient_id"
)

# Generate settings_matrix
settings_matrix <- generate_settings_matrix(
    data_list,
    nrow = 1,
    max_k = 40,
    seed = 42
)

# Run SNF and clustering
batch_snf_results <- batch_snf(
    data_list,
    settings_matrix,
    return_similarity_matrices = TRUE
)

solutions_matrix <- batch_snf_results$"solutions_matrix"
similarity_matrices <- batch_snf_results$"similarity_matrices"

# The first (and only) similarity matrix:
similarity_matrix <- similarity_matrices[[1]]

# The first (and only) cluster solution:
cluster_solution <- get_cluster_solutions(solutions_matrix)$"1"

```

## Visualize similarity matrices sorted by cluster label

`similarity_matrix_heatmap` is a wrapper for `ComplexHeatmap::Heatmap`, but with some convenient default transformations and parameters for viewing a similarity matrix.

```{r}

similarity_matrix_heatmap(
    similarity_matrix = similarity_matrix,
    cluster_solution = cluster_solution
)

```

The default transformations include plotting log(Similarity) rather than the default similarity matrix as well as rescaling the diagonal of the matrix to the average value of the off-diagonals.
Additionally, the similarity matrix gets reordered according to the provided cluster solution.
Here's what the same similarity matrix looks like without those transformations:

```{r}

similarity_matrix_heatmap(
    similarity_matrix = similarity_matrix,
    scale_diag = "none",
    log_graph = FALSE
)

```

## Exporting heatmaps

Here's an example of how you can save this heatmap (or any other heatmap created by `ComplexHeatmap::Heatmap`).

```{r eval = FALSE}

grDevices::png(
    "my_heatmap.png",
    width = 300,
    height = 300,
    units = "px",
)

similarity_matrix_heatmap(
    similarity_matrix = similarity_matrix,
    cluster_solution = cluster_solution
)

grDevices::dev.off()

```

## Annotations

One piece of functionality provided by `ComplexHeatmap::Heatmap` is the ability to supply visual annotations along the rows and columns of a heatmap.

You can always build annotations using the standard approaches outline in the [ComplexHeatmap Complete Reference](https://jokergoo.github.io/ComplexHeatmap-reference/book/index.html).
In addition to that, this package offers some convenient functionality to specify regular heatmap annotations and barplot annotations directly through a provided dataframe or data_list (or both).

In the example below, we make use of data supplied through a data_list.

```{r}

# Providing the data for the annotations through a data_list
set.seed(42)
similarity_matrix_heatmap(
    similarity_matrix = similarity_matrix,
    cluster_solution = cluster_solution,
    scale_diag = "mean",
    log_graph = TRUE,
    data_list = data_list,
    left_hm = list(
        "Diagnosis" = "diagnosis"
    ),
    top_hm = list(
        "Gender" = "gender"
    ),
    top_bar = list(
        "Age" = "age"
    )
)

```

The chunk below gives an identical plot, but using a dataframe instead of a data_list.

```{r eval = FALSE}

df <- collapse_dl(data_list) # Pools all the data in a data_list to a single df

# Providing the data for the annotations through an external dataframe
set.seed(42)
similarity_matrix_heatmap(
    similarity_matrix = similarity_matrix,
    cluster_solution = cluster_solution,
    scale_diag = "mean",
    log_graph = TRUE,
    data = df,
    left_hm = list(
        "Diagnosis" = "diagnosis"
    ),
    top_hm = list(
        "Gender" = "gender"
    ),
    top_bar = list(
        "Age" = "age"
    )
)

```

We needed to call `set.seed()` because by default, `ComplexHeatmap::Heatmap` randomly generates colours for heatmap annotations.
You can instead specify your own colours using the `annotation_colours` parameter:

```{r}

similarity_matrix_heatmap(
    similarity_matrix = similarity_matrix,
    cluster_solution = cluster_solution,
    scale_diag = "mean",
    log_graph = TRUE,
    data_list = data_list,
    left_hm = list(
        "Diagnosis" = "diagnosis"
    ),
    top_hm = list(
        "Gender" = "gender"
    ),
    top_bar = list(
        "Age" = "age"
    ),
    annotation_colours = list(
        Diagnosis = c(
            "definite asthma" = "red3",
            "possible asthma" = "pink1",
            "no asthma" = "bisque1"
        ),
        Gender = c(
            "female" = "purple",
            "male" = "lightgreen"
        )
    )
)

```

The colours `red3`, `pink1`, etc. are built-in R colours that you can browse by calling `colours()`.

For reference, the code below shows how you would achieve these annotations using standard `ComplexHeatmap` syntax.

```{r eval = FALSE}

merged_df <- collapse_dl(data_list)
order <- sort(cluster_solution, index.return = TRUE)$"ix"
merged_df <- merged_df[order, ]

top_annotations <- ComplexHeatmap::HeatmapAnnotation(
    Age = ComplexHeatmap::anno_barplot(merged_df$"age"),
    Gender = merged_df$"gender",
    #Atopic_Asthma = merged_df$"asthma",
    col = list(
        Gender = c(
            "female" = "purple",
            "male" = "lightgreen"
        )
    ),
    show_legend = TRUE
)

left_annotations <- ComplexHeatmap::rowAnnotation(
    Diagnosis = merged_df$"diagnosis",
    #Atopic_Asthma = merged_df$"asthma",
    col = list(
        Diagnosis = c(
            "definite asthma" = "red3",
            "possible asthma" = "pink1",
            "no asthma" = "bisque1"
        )
    ),
    show_legend = TRUE
)

similarity_matrix_heatmap(
    similarity_matrix = similarity_matrix,
    cluster_solution = cluster_solution,
    scale_diag = "mean",
    log_graph = TRUE,
    data = df,
    top_annotation = top_annotations,
    left_annotation = left_annotations
)

```

Take a look at the [ComplexHeatmap Complete Reference](https://jokergoo.github.io/ComplexHeatmap-reference/book/index.html) to learn more about what is possible with this package.

## More on sorting

Be aware that the ordering of both your data and your similarity matrix will be influenced if you supply values for the `cluster_solution` or `order` parameters.
If you don't think your data is lining up properly, consider manually making sure your `similarity_matrix` rows and columns are sorted to your preference (e.g., based on cluster) and that the order of your data matches.
This will be easier to do with a `dataframe` than with a `data_list`, as the `data_list` forces patients to be sorted by their unique IDs upon generation.

## Alluvial plots

Curious to see how cluster assignment of samples segregate in different number of clusters?
Now you can plot **Alluvial Plot** from a minimum of 2 clusters to a user-defined max number of clusters easily

Put together a list of clustering algorithms that range from 1 to the number of clusters you'd like to visualize in the alluvial plot:

```{r}

cluster_sequence <- list(
    spectral_two,
    spectral_three,
    spectral_four,
    spectral_five,
    spectral_six
)

```

```{r}


alluvial_df <- data.frame()

ncol(alluvial_df)


alluvial_cluster_plot <- function(cluster_sequence, similarity_matrix) {
    alluvial_df <- data.frame(subjectkey = colnames(similarity_matrix))
    for (algorithm in cluster_sequence) {
        cluster_output <- algorithm(similarity_matrix)
        solution <- cluster_output$"solution"
        nclust <- cluster_output$"nclust"
        solution_col <- data.frame(solution)
        colnames(solution_col) <- nclust
        alluvial_df <- cbind(alluvial_df, solution_col)
    }
    return(alluvial_df)
}
cluster_file2 <- alluvial_cluster_plot(cluster_sequence, similarity_matrix)

head(cluster_file2)

cluster_file <- output_cluster_file(similarity_matrix, numc = 6)


cluster_file

output_cluster_file(similarity_matrix, numc = 6)

head(cluster_file)

```

If you are familiar with alluvial plots and would like to create your own alluvial illustration, `prepare_for_alluvial_wDiagnosis` function generates a "category frequency" dataframe in wide format that you can use to create your own customized plot.
Otherwise, we have `cluster_alluvial` to conveniently plot alluvial colored by desired outcome variable.

```{r}

# Let's generate some example outcome variables added to cluster_file
cluster_file$"Wheeze_status" <- c(
    rep("Yes", 20),
    rep("Sometimes", 60),
    rep("No", 120)
)

alluvial_df <- prepare_for_alluvial_wDiagnosis(
    cluster_file,
    fill_alluvium_by = "Wheeze_status",
    numc = 6
)

alluvial_df

# this function assumes outcome variables to be in a separate dataframe, with sampleIDs in "Subject_Number" column
# Let's generate some outcome variables
df_outcomes = data.frame(
    Subject_Number = as.character(rownames(cluster_file)),
    Wheeze_status = c(rep("Yes", 20), rep("Sometimes", 60), rep("No", 120))
)

df_outcomes2 = data.frame(
    Subject_Number = as.character(rownames(cluster_file2)),
    Wheeze_status = c(rep("Yes", 20), rep("Sometimes", 60), rep("No", 120))
)

head(df_outcomes)

head(df_outcomes2)

cluster_alluvial(
    similarity_matrix = similarity_matrix,
    df_env = df_outcomes,
    numc = 6,
    outcome = "Wheeze_status"
)

```

`Wheeze status` may be just one of the many outcomes that is part of asthma diagnosis. In heterogeneous diseases, "Asthma_Diagnosis" is the ultimate outcome. To display it alongside `Wheeze status`:

```{r}

df_outcomes$Asthma_Diagnosis <- c(
    rep("Definite Asthma", 10),
    rep("Possible Asthma", 50),
    rep("No Asthma", 140)
)

cluster_alluvial(
    similarity_matrix = similarity_matrix,
    df_env = df_outcomes,
    numc = 6,
    outcome = "Wheeze_status",
    key_outcome = "Asthma_Diagnosis"
)

```


### Part2 - Calculate and display associations between clusters and outcomes

In downstream data analysis for heterogeneous disease, it is often hard to see clear cluster separation by outcome with heatmap due to the large amount of datatypes/predictive features not capturing the entireity of disease. For example, an integration could integrate datatype `blood`:

- white blood cell count at 1 year of age (10 features)

- white blood cell count at 5 year of age (10 features)

Another integration could integrate datatype `Gut_microbiome`

- gut microbial species relative abundances at 3 month of age (300 features)

- gut microbial species relative abundances at 1 year of age (350 features)


and not provding clear indication to asthma diagnosis. However there could still be cluster assignment that associates with your outcome-of-interest.

In this case, we want to find which integration cluster result (thus dataset(s) used for that integration) show significant association to outcomes-of-interest and display with Manhattan plot.

As of now this function does not recognize data type (categorical or continuous) automatically, so we recommend running categorical outcomes and continuous outcomes separately. Let's assume the matrix `W` is an integration of the two datasets from `blood` datatype

```{r}

outcomes = c('Asthma_Diagnosis','Atopic_Asthma')

# have a column for sampleID. Make sure cluster column is also in df
df_blood = data.frame(sampleID = seq(1:200),
                cluster = cluster_solution,
                Asthma_Diagnosis = diagnoses,
                Atopic_Asthma = asthmas)
df_blood

outcomes = c('Asthma_Diagnosis','Atopic_Asthma')

# because both outcomes are categorical, we use chi-squared test. Assume the input data has 200 samples
output <- clusterToOutcomeCorr(
    df_blood,
    outcomes = outcomes,
    method = "chi-squared",
    datatype = "blood",
    size = 200
)

output

```

You can keep adding more data/row by running this function again and again, with appropriate test method. Let's add a continuous outcome for lung function `Pre_FEV1_zscore`

```{r}

set.seed(100)
# again, randomly generate some numbers
df_blood$Pre_FEV1_zscore = runif(200)

outcomes = c("Pre_FEV1_zscore")
output = rbind(output, clusterToOutcomeCorr(df_blood, outcomes = outcomes, method = "kruskal", datatype = "blood", size = 200))
output

```

Let's have another matrix for `Gut_microbiome` integration datatype and add some more data for cluster-outcome association tests

```{r}

set.seed(100)
# lets say there are 150 samples. Generate a random number matrix for gut_microbiome integration
W_gut1 <- matrix(runif(300 * 300), nrow = 300, ncol = 300)
W_gut2 <- matrix(runif(300 * 300), nrow = 300, ncol = 300)
W_gut = SNF(list(W_gut1,W_gut2), 20, 20)

# let's say we go with 4 clusters for gut datatype, you can decide your optimal cluster number
group_cluster_gut = spectralClustering(W_gut, K = 4)

# generate table with outcomes in
df_gut = data.frame(
    sampleID = seq(1:300),
    cluster = group_cluster_gut,
    Asthma_Diagnosis = sample(diagnosis, 300, replace = TRUE),
    Atopic_Asthma = sample(atopic_asthma, 300, replace = TRUE)
)

# same as before, add categorical outcomes
outcomes = c('Asthma_Diagnosis','Atopic_Asthma')

output = rbind(
    output,
    clusterToOutcomeCorr(
        df_gut,
        outcomes = outcomes,
        method = "chi-squared",
        datatype = "gut_microbiome",
        size = 300
    )
)

output

# add continuous outcome
df_gut$Pre_FEV1_zscore = runif(300)

outcomes = c("Pre_FEV1_zscore")

output = rbind(
    output,
    clusterToOutcomeCorr(
        df_gut,
        outcomes = outcomes,
        method = "kruskal",
        datatype = "gut_microbiome",
        size = 300
    )

)

output

```

Next we can feed this dataframe to plot manhanttan using `clusterToOutcomeManhattan`

```{r}

clusterToOutcomeManhattan(output)

```

The red dotted line represent p-value of 0.05 cutoff. The black dotted line represent the 0.05 cutoff divided by the number of data types which act as a multiple comparison correction.

### Part 3 - correlation heatmap
If we are to look at predictor-predictor or outcome-outcome correlation, we can plot the correlation heatmap using, again, ComplexHeatmap. Make sure you provide the p-values from correlation tests

```{r}

# generate a mock correlation table
corr_predictor <- matrix(runif(50 * 50), nrow = 50, ncol = 50)
rownames(corr_predictor) = seq(1:50)
colnames(corr_predictor) = seq(1:50)

# color by data types (optional). Say first 25 outcomes are from blood datatype, the next 25 from gut_microbiome datatype
labels <- c("Blood", "Gut_microbiome")
color = c(rep("#cd34b5", 25), rep("goldenrod4", 25))

corrHeatmap(
    corr_predictor,
    labels_color = color,
    row_km = 4,
    column_km = 4
)

```

Next let's generate heatmap legend. This function as of now will output legend to a file

```{r}

labels_color = c("#cd34b5", "goldenrod4")

corrHeatmap_legend(
    "test_func.png",
    labels = labels,
    labels_color = labels_color
)

```

### Part 4 Manhattan plot of correlation to one key outcome

We can also plot correlation of features to **one** user-specified outcome in Manhattan. This is useful if you are doing abSNF where correlation of features to **one** outcome is pre-calculated and you want to see the correlation. The more correlated feature indicates more up-weighing in abSNF.

*Note: abSNF = Association-signal-annotation Boosted Similarity Network Fusion

Similar to running `clusterToOutcomeCorr`, here we have pre-calculated correlation p-value between each predictive feature to "Asthma_Diagnosis". For convenience let's generate some numbers

```{r}

#'  "p.value": from correlation test,
#'  "n": number of samples,
#'  "Group": datatype name,
#'  "Group_index": sequence of datatypes to be displayed
#'
predictor_df = data.frame(
    p.value = c(0.002, 0.03, 0.01, 0.09, 0.02, 0.085),
    n = c(200, 100, 150, 70, 45, 80),
    Group = c(
        rep("home environment 3m", 2),
        rep("parental status", 4)
    ),
    Group_Index = c(rep(1, 2), rep(2,4))
)

rownames(predictor_df) <- c(
    "home_DEP_3m",
    "home_DNBP_3m",
    "Asthma_mother",
    "Asthma_father",
    "Wheeze_mother",
    "Wheeze_father"
)

predictor_df

# set dataset labels
labels <- c("home environment 3m", "parental status")

CorrManhattan(
    predictor_df,
    outcome = "Asthma Diagnosis",
    dataset_label = labels
)

```

The red line represents p-value at 0.05. Now you can see which dataset has features (dots) more associated to asthma outcome.

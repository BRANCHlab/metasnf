#' Build solutions matrix
#'
#' The matrix that will contain all the columns to be populated by SNF results.
#'
#' @param data_list nested list of input data generated by the function
#'  `get_data_list()`
#' @param settings_matrix matrix indicating parameters to iterate SNF through
#'
#' @return solutions_matrix The solutions matrix
#'
#' @export
generate_solutions_matrix <- function(data_list, settings_matrix) {
    subjects <- list()
    for (i in seq_along(data_list)) {
        subjects <- append(subjects, (data_list[[i]][[1]]$"subjectkey"))
    }
    subjects <- unique(unlist(subjects))
    solutions_matrix <- add_columns(settings_matrix, subjects, 0)
    other_cols <- c(
        "eigen_best",
        "rot_best",
        "cbcl_nausea_p",
        "cbcl_vomiting_p",
        "cbcl_dizzy_p",
        "cbcl_overtired_p",
        "cbcl_sleeping_more_p",
        "cbcl_sleeping_less_p",
        "cbcl_depress_p",
        "cbcl_anxiety_p",
        "cbcl_attention_p",
        "cbcl_aggressive_p",
        "min_p_val",
        "mean_p_val")
    solutions_matrix <- add_columns(solutions_matrix, other_cols, 0)
    return(solutions_matrix)
}

#' Extend an solutions matrix to include outcome evaluations
#'
#' @param solutions_matrix A solutions_matrix.
#' @param target_list A target_list.
#' @param cat_test String indicating which statistical test will be used to
#' associate cluster with a categorical variable. Options are "chi_squared" for
#' the Chi-squared test and "fisher_exact" for Fisher's exact test.
#'
#' @return extended_solutions_matrix an extended solutions matrix that contains
#'  p-value columns for each outcome in the provided target_list
#'
#' @export
extend_solutions <- function(solutions_matrix,
                             target_list,
                             cat_test = "chi_squared") {
    # Single vector of all feature names
    ol_features <- lapply(
        target_list,
        function(x) {
            # All the features from each target list dataframe
            colnames(x[[1]])[-1]
        }
    ) |> unlist()
    # Single vector of all feature types
    ol_feature_types <- lapply(
        target_list,
        function(x) {
            n_features <- ncol(x$"data") - 1
            outcome_type <- rep(x$"type", n_features)
        }
    ) |> unlist()
    # Add columns tracking p-values of all features
    # Specifying the dataframe structure avoids tibble-related errors
    solutions_matrix <- data.frame(solutions_matrix)
    solutions_matrix <- add_columns(
        solutions_matrix,
        paste0(ol_features, "_p"),
        fill = NA
    )
    # Single DF to contain all outcome features
    merged_df <- lapply(
        target_list,
        function(x) {
            x[[1]]
        }) |> merge_df_list()
    # Store rows that raise chi_squared warnings
    chi_squared_warnings <- vector()
    # Iterate across rows of the solutions matrix
    for (i in seq_len(nrow(solutions_matrix))) {
        clustered_subs <- get_clustered_subs(solutions_matrix[i, ])
        # This really shouldn't be different from clustered_subs
        assigned_subs <- clustered_subs |>
            dplyr::filter(clustered_subs$"cluster" != 0)
        # Iterate across each outcome measure included
        # Assign p-values
        for (j in 1:length(ol_features)) {
            #current_outcome_component <- target_list[[j]]
            current_outcome_component <- merged_df[, c(1, j + 1)]
            current_outcome_type <- ol_feature_types[j]
            current_outcome_name <- colnames(current_outcome_component)[2]
            try_catch_results <- tryCatch(
                expr = {
                    p_value <- get_cluster_pval(
                        assigned_subs,
                        current_outcome_component,
                        ol_feature_types[j],
                        ol_features[j],
                        cat_test = cat_test
                    )
                    list(
                        "p_value" = p_value,
                        "chi_squared_warnings" = chi_squared_warnings
                    )
                },
                warning = function(w, row = i) {
                    if(grep("Chi-squared", w$"message")) {
                        chi_squared_warnings <- c(chi_squared_warnings, row)
                        suppressWarnings(
                            p_value <- get_cluster_pval(
                                assigned_subs,
                                current_outcome_component,
                                ol_feature_types[j],
                                ol_features[j],
                                cat_test = cat_test
                            )
                        )
                        list(
                            "p_value" = p_value,
                            "chi_squared_warnings" = chi_squared_warnings
                        )
                    } else {
                        p_value <- get_cluster_pval(
                            assigned_subs,
                            current_outcome_component,
                            ol_feature_types[j],
                            ol_features[j]
                        )
                        list(
                            "p_value" = p_value,
                            "chi_squared_warnings" = chi_squared_warnings
                        )
                    }
                }
            )
            p_value <- try_catch_results$"p_value"
            chi_squared_warnings <- try_catch_results$"chi_squared_warnings"
            target_col <- grep(current_outcome_name, colnames(solutions_matrix))
            solutions_matrix[i, target_col] <- p_value
        }
        min_p <- get_min_p(solutions_matrix[i, ])
        mean_p <- get_mean_p(solutions_matrix[i, ])
        solutions_matrix[i, "min_p_val"] <- min_p
        solutions_matrix[i, "mean_p_val"] <- mean_p
    }
    if (length(chi_squared_warnings) > 0) {
        chi_squared_warnings <- paste(chi_squared_warnings, collapse = ", ")
        warning(
            "In calculating p-values for the following rows of the solutions",
            " matrix: [", chi_squared_warnings, "], the Chi-squared test was",
            " applied on a table that had at least one cell containing fewer",
            " than 5 elements. Please note that when the expected number of",
            " elements per cell is less than 5, an assumption in the test is",
            " violated. To avoid seeing this message, re-run the",
            " `extend_solutions` function with the parameter",
            " `cat_test = \"fisher_exact\"`, which uses Fisher's exact test."
        )
    }
    return(solutions_matrix)
}

#' Select p-values from solutions matrix
#'
#' @param solutions_matrix The output of batch_snf
#'
#' @return p_val_matrix P-values ready for heatmap plotting
#'
#' @export
p_val_select <- function(solutions_matrix) {
    p_val_matrix <- solutions_matrix |>
        dplyr::select(
            "row_id",
            dplyr::ends_with("_p"),
            -c("min_p_val", "mean_p_val")) |>
        data.frame() |>
        numcol_to_numeric()
    return(p_val_matrix)
}

#' Get minimum p-value
#'
#' Given an solutions matrix row containing evaluated p-values, returns min.
#'
#' @param solutions_matrix_row row of solutions_matrix object
#'
#' @return min_p minimum p-value
#'
#' @export
get_min_p <- function(solutions_matrix_row) {
    min_p <- solutions_matrix_row |>
        dplyr::mutate(dplyr::across(dplyr::ends_with("_p"), ~ as.numeric(.))) |>
        dplyr::select(dplyr::ends_with("_p")) |>
        min()
    return(min_p)
}

#' Get mean p-value
#'
#' Given an solutions matrix row containing evaluated p-values, returns mean.
#'
#' @param solutions_matrix_row row of solutions_matrix object
#'
#' @return mean_p mean p-value
#'
#' @export
get_mean_p <- function(solutions_matrix_row) {
    mean_p <- solutions_matrix_row |>
        dplyr::mutate(dplyr::across(dplyr::ends_with("_p"), ~ as.numeric(.))) |>
        dplyr::select(dplyr::ends_with("_p")) |>
        rowMeans()
    return(mean_p)
}

#' Get p-value
#'
#' Depending on outcome measure, perform ordinal regression or linear regression
#'  and return p-value as a benchmark measure of how well-separated clusters
#'  are by the outcome measure.
#'
#' @param assigned_subs dataframe of subjects who were assigned to a cluster
#' and the cluster they were assigned to.
#' @param outcome_df dataframe containing subjectkey and outcome feautre column
#' @param outcome_type string indicating the outcome type (numeric or ordinal)
#' @param outcome_name string indicating the name of the feature
#' @param cat_test String indicating which statistical test will be used to
#' associate cluster with a categorical variable. Options are "chi_squared" for
#' the Chi-squared test and "fisher_exact" for Fisher's exact test.
#'
#' @return p_val the smallest p-value of interest
#'
#' @export
get_cluster_pval <- function(assigned_subs,
                     outcome_df,
                     outcome_type,
                     outcome_name,
                     cat_test = "chi_squared") {
    # Dataframe containing cluster membership and outcome variable as cols
    merged_df <- dplyr::inner_join(
        assigned_subs,
        outcome_df,
        by = "subjectkey"
    )
    if (outcome_type == "ordinal") {
        pval <- ord_reg_pval(
            predictor = factor(merged_df$"cluster"),
            response = merged_df[, outcome_name]
        )
    } else if (outcome_type == "numeric") {
        pval <- linear_model_pval(
            predictor = factor(merged_df$"cluster"),
            response = merged_df[, outcome_name]
        )
    } else if (outcome_type == "categorical") {
        if (cat_test == "chi_squared") {
            pval <- chi_squared_pval(
                merged_df$"cluster",
                merged_df[, outcome_name]
            )
        } else if (cat_test == "fisher_exact") {
            pval <- fisher_exact_pval(
                merged_df$"cluster",
                merged_df[, outcome_name]
            )
        }
    } else {
        stop(
            "Unsupported outcome type: ", outcome_type,
            ". Accepted types for now are numeric and ordinal."
        )
    }
    return(pval)
}

#' Get p-value (deprecated)
#'
#' Depending on outcome measure, perform ordinal regression or linear regression
#'  and return p-value as a benchmark measure of how well-separated clusters
#'  are by the outcome measure.
#'
#' @param assigned_subs dataframe of subjects who were assigned to a cluster
#' and the cluster they were assigned to.
#' @param outcome_df dataframe containing subjectkey and outcome feautre column
#' @param outcome_type string indicating the outcome type (numeric or ordinal)
#' @param outcome_name string indicating the name of the feature
#' @param cat_test String indicating which statistical test will be used to
#' associate cluster with a categorical variable. Options are "chi_squared" for
#' the Chi-squared test and "fisher_exact" for Fisher's exact test.
#'
#' @return p_val the smallest p-value of interest
#'
#' @export
get_p <- function(assigned_subs,
                  outcome_df,
                  outcome_type,
                  outcome_name,
                  cat_test = "chi_squared") {
    if (outcome_type == "ordinal") {
        p_val <- ord_reg_p(assigned_subs, outcome_df, outcome_name)
    } else if (outcome_type == "numeric") {
        p_val <- lin_reg_p(assigned_subs, outcome_df, outcome_name)
    } else if (outcome_type == "categorical") {
        if (cat_test == "chi_squared") {
            p_val <- chi_sq_p(assigned_subs, outcome_df, outcome_name)
        } else if (cat_test == "fisher_exact") {
            print(NULL)
        }
    } else {
        stop(paste0(
            "Unsupported outcome type: ",
            outcome_type,
            ". Accepted types for now are numeric and ordinal."
        ))
    }
    return(p_val)
}

#' Ordinal regression p-value (deprecated)
#'
#' Returns the p-value following an ordinal regression in which cluster
#'  is the IV and a provided ordinal variable is the DV.
#'
#' @param clust_membership Dataframe of cluster membership (get_clustered_subs)
#' @param outcome_df Dataframe containing DV
#' @param outcome_var DV as a string
#'
#' @return p_val The overall p-value distinguishing clusters by the DV
#'
#' @export
ord_reg_p <- function(clust_membership, outcome_df, outcome_var) {
    merged_df <-
        dplyr::inner_join(clust_membership, outcome_df, by = "subjectkey")
    num_classes <- length(unique(merged_df[, outcome_var]))
    # If there are only 2 tiers to the ordinal scale, just use linear model
    if (num_classes == 2) {
        return(lin_reg_p(clust_membership, outcome_df, outcome_var))
    }
    merged_df$"cluster" <- as.factor(merged_df$"cluster")
    merged_df[, outcome_var] <- as.ordered(merged_df[, outcome_var])
    null_model <- MASS::polr(merged_df[, outcome_var] ~ 1)
    full_model <- MASS::polr(merged_df[, outcome_var] ~ merged_df[, "cluster"])
    p_value <- stats::anova(null_model, full_model)$"Pr(Chi)"[2]
    return(p_value)
}

#' Ordinal regression p-value
#'
#' Returns the overall p-value of an ordinal regression on a categorical
#' predictor and response vetors. If the ordinal response
#'
#' @param predictor A categorical or numeric variable.
#' @param response A numeric variable.
#'
#' @export
ord_reg_pval <- function(predictor, response) {
    # If there are only 2 tiers to the ordinal scale, just use linear model
    num_classes <- length(unique(response))
    if (num_classes == 2) {
        return(linear_model_pval(predictor, response))
    }
    # Otherwise, run regular ordinal regression
    response <- as.ordered(response)
    null_model <- MASS::polr(response ~ 1)
    full_model <- MASS::polr(response ~ predictor)
    pval <- stats::anova(null_model, full_model)$"Pr(Chi)"[2]
    return(pval)
}

#' Linear regression p-value
#'
#' Returns the p-value following an linear regression in which cluster
#'  is the IV and a provided ordinal variable is the DV.
#'
#' @param clust_membership Dataframe of cluster membership (get_clustered_subs)
#' @param outcome_df Dataframe containing DV
#' @param outcome_var DV as a string
#'
#' @return p_val The overall p-value distinguishing clusters by the DV
#'
#' @export
lin_reg_p <- function(clust_membership, outcome_df, outcome_var) {
    merged_df <-
        dplyr::inner_join(clust_membership, outcome_df, by = "subjectkey")
    merged_df$"cluster" <- as.factor(merged_df$"cluster")
    model <- stats::lm(merged_df[, outcome_var] ~ merged_df[, "cluster"])
    fstat <- summary(model)$"fstatistic"
    p <- stats::pf(fstat[1], fstat[2], fstat[3], lower.tail = FALSE)
    attributes(p) <- NULL
    return(p)
}

#' Chi-squared test p-value
#'
#' Returns the p-value following a chi-squared test (without Yates' continuity
#'  correction) on the distribution of a categorical variable by cluster.
#'
#' @param clust_membership Dataframe of cluster membership (get_clustered_subs)
#' @param outcome_df Dataframe containing outcome feature
#' @param outcome_var Outcome feature as a string
#'
#' @return p_val The chi-squared test p-value
#'
#' @export
chi_sq_p <- function(clust_membership, outcome_df, outcome_var) {
    # This dataframe merges clust_membership, which has the cluster of each
    #  column, with outcome_df, which has the data of each subject on the
    #  outcome feature being evaluated.
    merged_df <-
        dplyr::inner_join(clust_membership, outcome_df, by = "subjectkey")
    merged_df$"cluster" <- as.factor(merged_df$"cluster")
    model <- stats::chisq.test(
            merged_df[, "cluster"],
        merged_df[, outcome_var],
        correct = FALSE
    )
    p <- model$"p.value"
    return(p)
}

#' Chi-squared test p-value (generic)
#'
#' Return p-value for chi-squared test for any two variables
#'
#' @param cat_var1 A categorical variable.
#' @param cat_var2 A categorical variable.
#'
#' @return pval A p-value.
#'
#' @export
chi_squared_pval <- function(cat_var1, cat_var2) {
    cat_var1 <- factor(cat_var1)
    cat_var2 <- factor(cat_var2)
    model <- stats::chisq.test(cat_var1, cat_var2, correct = FALSE)
    pval <- model$"p.value"
    attributes(pval) <- NULL
    return(pval)
}

#' Fisher exact test p-value
#'
#' Return p-value for Fisher exact test for any two variables
#'
#' @param cat_var1 A categorical variable.
#' @param cat_var2 A categorical variable.
#'
#' @return pval A p-value.
#'
#' @export
fisher_exact_pval <- function(cat_var1, cat_var2) {
    cat_var1 <- factor(cat_var1)
    cat_var2 <- factor(cat_var2)
    print("dog")
    model <- stats::fisher.test(cat_var1, cat_var2, workspace=2e7)
    pval <- model$"p.value"
    attributes(pval) <- NULL
    return(pval)
}

#' Linear model p-value (generic)
#'
#' Return p-value of F-test for a linear model of any two variables
#'
#' @param predictor A categorical or numeric variable.
#' @param response A numeric variable.
#'
#' @return pval A p-value.
#'
#' @export
linear_model_pval <- function(predictor, response) {
    model <- stats::lm(response ~ predictor)
    fstat <- summary(model)$"fstatistic"
    pval <- stats::pf(fstat[1], fstat[2], fstat[3], lower.tail = FALSE)
    attributes(pval) <- NULL
    return(pval)
}

#' Calculate p-values based on variable vectors and their types
#'
#' @param var1 A single vector containing a variable.
#' @param var2 A single vector containing a variable.
#' @param type1 The type of var1 (continuous, discrete, ordinal, categorical).
#' @param type2 The type of var2 (continuous, discrete, ordinal, categorical).
#' @param cat_test String indicating which statistical test will be used to
#' associate cluster with a categorical variable. Options are "chi_squared" for
#' the Chi-squared test and "fisher_exact" for Fisher's exact test.
#'
#' @return pval A p-value from a statistical test based on the provided types.
#'  Currently, this will either be the F-test p-value from a linear model
#'  if at least one variable is non-categorical, or the chi-squared test
#'  p-value if both variables are categorical.
#'
#' @export
calculate_association_pval <- function(var1,
                                       var2,
                                       type1,
                                       type2,
                                       cat_test = "chi_squared") {
    types <- c(type1, type2)
    numeric_vars <- c("continuous", "discrete", "ordinal")
    if (all(types %in% numeric_vars)) {
        # numeric vs. numeric
        num_var1 <- as.numeric(unlist(var1))
        num_var2 <- as.numeric(unlist(var2))
        pval <- linear_model_pval(num_var1, num_var2)
    } else if (all(types %in% "categorical")) {
        # categorical vs. categorical
        cat_var1 <- factor(unlist(var1))
        cat_var2 <- factor(unlist(var2))
        if (cat_test == "chi_squared") {
            pval <- chi_squared_pval(cat_var1, cat_var2)
        } else if (cat_test == "fisher_exact") {
            pval <- fisher_exact_pval(cat_var1, cat_var2)
        }
    } else {
        # numeric vs. categorical
        if (which(types %in% numeric_vars) == 1) {
            num_var <- as.numeric(unlist(var1))
            cat_var <- factor(unlist(var2))
        } else {
            num_var <- as.numeric(unlist(var2))
            cat_var <- factor(unlist(var1))
        }
        pval <- linear_model_pval(predictor = cat_var, response = num_var)
    }
    return(pval)
}

#' Calculate p-values for pairwise associations of variables in a data_list
#'
#' @param data_list data_list containing variables for pairwise associations.
#' @param verbose If TRUE, prints new line everytime a p-value is being
#'  calculated.
#' @param key_association If a variable is named, returns a dataframe of
#'  p-values relative to that variable rather than all pairwise p-values.
#' @param drop_self If key_association is specified and drop_self is TRUE,
#'  removes the p-value row of the key_association variable with itself (0).
#' @param cat_test String indicating which statistical test will be used to
#' associate cluster with a categorical variable. Options are "chi_squared" for
#' the Chi-squared test and "fisher_exact" for Fisher's exact test.
#'
#' @export
calculate_associations <- function(data_list,
                                   verbose = FALSE,
                                   key_association = NULL,
                                   drop_self = TRUE,
                                   cat_test = "chi_squared") {
    ###########################################################################
    # Ensure that 'mixed' data type is not being used
    ###########################################################################
    dl_summary <- summarize_dl(data_list)
    if (any(dl_summary$"type" == "mixed")) {
        warning(
            "When using the 'mixed' data type in the 'calculate_associations'",
            " function, any data that can be converted to numeric format will",
            " be treated as continuous and all others will be treated as",
            " categorical. If you do not want this behaviour, please",
            " restructure your input data to only use the following types:",
            " continuous, discrete, ordinal, or categorical."
        )
    }
    ###########################################################################
    # Build a single data.frame that contains all data
    ###########################################################################
    merged_df <- collapse_dl(data_list)
    merged_df <- merged_df[, colnames(merged_df) != "subjectkey"]
    ###########################################################################
    # Build data.frame containing the types of variables in merged_df
    ###########################################################################
    types <- data_list |> lapply(
        function(x) {
            rep(x$"type", ncol(x$"data") - 1)
        }
    ) |> unlist()
    domains <- data_list |> lapply(
        function(x) {
            rep(x$"domain", ncol(x$"data") - 1)
        }
    ) |> unlist()
    var_names <- colnames(merged_df[, colnames(merged_df) != "subjectkey"])
    metadata <- data.frame(
        name = var_names,
        type = types,
        domain = domains
    )
    ###########################################################################
    # Loop through all pairs of variables
    ###########################################################################
    pairwise_indices <- utils::combn(ncol(merged_df), 2)
    association_matrix <- matrix(ncol = ncol(merged_df), nrow = ncol(merged_df), 0)
    colnames(association_matrix) <- colnames(merged_df)
    rownames(association_matrix) <- colnames(merged_df)
    for (col in seq_len(ncol(pairwise_indices))) {
        ## The positions of the two variables in the merged dataframe
        ind1 <- pairwise_indices[1, col]
        ind2 <- pairwise_indices[2, col]
        # The actual variables
        var1 <- merged_df[, ind1]
        var2 <- merged_df[, ind2]
        # The names of the variables
        var1_name <- colnames(merged_df)[ind1]
        var2_name <- colnames(merged_df)[ind2]
        # Types of the variables
        var1_type <- metadata[metadata$"name" == var1_name, "type"]
        var2_type <- metadata[metadata$"name" == var2_name, "type"]
        # Output current comparison if user specified verbose = TRUE
        if (verbose) {
            print(
                paste0(
                    "Calculating ", var1_name, " (", var1_type, ") vs.",
                    " ", var2_name, " (", var2_type, ")..."
                ),
                quote = FALSE
            )
        }
        #######################################################################
        # Calculate p-values
        #######################################################################
        pval <- calculate_association_pval(
            var1,
            var2,
            var1_type,
            var2_type,
            cat_test
        )
        if (is.na(pval)) {
            stop(
                "Error returned when comparing ", var1_name, " with ",
                var2_name, ". Are you sure these are the correct types?"
            )
        }
        association_matrix[ind1, ind2] <- pval
        association_matrix[ind2, ind1] <- pval
    }
    if (!is.null(key_association)) {
        # The user has specified a key_association value.
        key_associations_df <- data.frame(
            name = names(association_matrix[key_association, ]),
            pval = association_matrix[key_association, ]
        )
        rownames(key_association) <- NULL
        key_associations_df <- dplyr::inner_join(
            key_associations_df,
            metadata,
            by = "name"
        )
        # Remove the 0 p-value for the association of the variable with self
        if (drop_self) {
            keep_rows <- key_associations_df$"name" != key_association
            key_associations_df <- key_associations_df[keep_rows, ]
        }
        return(key_associations_df)
    } else {
        # The user has not specified a key_association value, provide the full
        #  pairwise association matrix.
        return(association_matrix)
    }
}

#' Get clustered subjects
#'
#' Pull a dataframe of clustered subjects from an solutions matrix structure.
#'
#' @param solutions_matrix_row Output matrix row containing subtype membership
#'
#' @return clustered_subs Dataframe
#'
#' @export
get_clustered_subs <- function(solutions_matrix_row) {
    solutions_matrix_row <- data.frame(solutions_matrix_row)
    clustered_subs <-
        data.frame(
            t(
                solutions_matrix_row[
                    1,
                    which(startsWith(colnames(solutions_matrix_row), "subject_"))
                ]
            )
        )
    clustered_subs$"subjectkey" <- rownames(clustered_subs)
    rownames(clustered_subs) <- NULL
    clustered_subs <- clustered_subs |>
        dplyr::select("subjectkey", dplyr::starts_with("X")) |>
        dplyr::rename("cluster" = dplyr::starts_with("X"))
    return(clustered_subs)
}

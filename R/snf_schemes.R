#' Domain merge
#'
#' @description
#' Given a data_list, returns a new data_list where all original data objects of
#'  a particlar domain have been concatenated
#'
#' @param data_list nested list of input data generated by the function
#'  `get_data_list()`
#'
#' @return domain_dl
#'
#' @export
domain_merge <- function(data_list) {
    domain_dl <- list()
    for (i in seq_along(data_list)) {
        current_component <- data_list[[i]]
        current_domain <- data_list[[i]]$"domain"
        if (length(domain_dl) == 0) {
            domain_dl <- append(domain_dl, list(current_component))
            existing_match_pos <- which(domains(domain_dl) == current_domain)
            existing_component <- domain_dl[[existing_match_pos]]
            existing_match_data <- existing_component$"data"
            data_to_merge <- current_component$"data"
            merged_data <- dplyr::inner_join(
                existing_match_data, data_to_merge, by = "subjectkey")
            merged_component <- existing_component
            merged_component$"data" <- merged_data
            merged_component$"name" <-
                paste0("merged_", merged_component$"domain")
            merged_component$"type" <- dplyr::case_when(
                existing_component$"type" == current_component$"type" ~
                    current_component$"type",
                existing_component$"type" != current_component$"type" ~
                    "mixed"
            )
            domain_dl[[existing_match_pos]] <- merged_component
        } else {
            domain_dl <- append(domain_dl, list(current_component))
        }
    }
    return(domain_dl)
}

#' Two step SNF
#'
#' @description
#' Individual dataframes into individual similarity matrices into one fused
#'  network per domain into one final fused network.
#'
#' @param data_list nested list of input data generated by the function
#'  `get_data_list()`
#' @param k k hyperparameter
#' @param alpha alpha/eta/sigma hyperparameter
#' @param t SNF number of iterations hyperparameter
#'
#' @return fused_network The final fused network for clustering
#'
#' @export
two_step_merge <- function(data_list, k = 20, alpha = 0.5, t = 20) {
    dist_list <- lapply(data_list,
        function(x) {
            get_dist_matrix(df = x$"data", input_type = x$"type")
        })
    sim_list <- lapply(dist_list,
        function(x) {
            SNFtool::affinityMatrix(x, K = k, sigma = alpha)
        })
    affinity_list <- data_list
    for (i in seq_along(affinity_list)) {
        affinity_list[[i]]$"data" <- sim_list[[i]]
    }
    affinity_unique_dl <- list()
    unique_domains <- unique(unlist(domains(affinity_list)))
    for (i in seq_along(unique_domains)) {
        affinity_unique_dl <- append(affinity_unique_dl, list(list()))
    }
    names(affinity_unique_dl) <- unique_domains
    for (i in seq_along(affinity_list)) {
        al_current_domain <- affinity_list[[i]]$"domain"
        al_current_amatrix <- affinity_list[[i]]$"data"
        audl_domain_pos <- which(names(affinity_unique_dl) == al_current_domain)
        affinity_unique_dl[[audl_domain_pos]] <-
            append(affinity_unique_dl[[audl_domain_pos]],
            list(al_current_amatrix))
    }
    # Fusing individual matrices into domain affinity matrices
    step_one <- lapply(affinity_unique_dl,
       function(x) {
           if (length(x) == 1) {
               x[[1]]
           } else {
               SNFtool::SNF(Wall = x, K = k, t = t)
           }
       })
    # Fusing domain affinity matrices into final fused network
    if (length(step_one) > 1) {
        fused_network <- SNFtool::SNF(Wall = step_one, K = k, t = t)
    } else {
        fused_network <- step_one[[1]]
    }
    return(fused_network)
}

#' SNF a data_list
#'
#' @param data_list nested list of input data generated by the function
#'  `get_data_list()`
#' @param scheme Which SNF system to use to achieve the final fused network
#' @param k k hyperparameter
#' @param alpha alpha/eta/sigma hyperparameter
#' @param t SNF number of iterations hyperparameter
#'
#' @return fused_network The final fused network for clustering
#'
#' @export
snf_step <- function(data_list, scheme, k = 20, alpha = 0.5, t = 20) {
    # Subset just to those patients who are common in all inputs
    data_list <- data_list |>
        reduce_dl_to_common() |>
        arrange_dl()
    # Remove NAs function can go here later
    # The individual scheme creates similarity matrices for each dl element
    #  and pools them all into a single SNF run
    if (scheme %in% c("individual", 1)) {
        dist_list <- lapply(data_list,
            function(x) {
                get_dist_matrix(df = x$"data", input_type = x$"type")
            })
        sim_list <- lapply(dist_list,
            function(x) {
                SNFtool::affinityMatrix(x, K = k, sigma = alpha)
            })
        fused_network <- SNFtool::SNF(Wall = sim_list, K = k, t = t)
    # The domain scheme first runs domain merge on the data list (concatenates
    #  any data of the same domain) and then pools the concatenated data into a
    #  single SNF run
    } else if (scheme %in% c("domain", 2)) {
        data_list <- domain_merge(data_list)
        dist_list <- lapply(data_list,
            function(x) {
                get_dist_matrix(df = x$"data", input_type = x$"type",
                    scale = TRUE)
            })
        sim_list <- lapply(dist_list,
            function(x) {
                SNFtool::affinityMatrix(x, K = k, sigma = alpha)
            })
        fused_network <- SNFtool::SNF(Wall = sim_list, K = k, t = t)
    # The twostep scheme
    } else if (scheme %in% c("twostep", 3)) {
        fused_network <- two_step_merge(data_list)
    } else {
        rlang::abort(
            paste0("The value '", scheme, "' is not a valid snf scheme."),
            class = "invalid_input")
    }
    return(fused_network)
}

#' SNF a data_list
#'
#' @param data_list nested list of input data generated by the function
#'  `get_data_list()`
#' @param scheme Which SNF system to use to achieve the final fused network
#' @param k k hyperparameter
#' @param alpha alpha/eta/sigma hyperparameter
#' @param t SNF number of iterations hyperparameter
#' @param cont_dist_fn distance metric function for continuous data
#' @param disc_dist_fn distance metric function for discrete data
#' @param ord_dist_fn distance metric function for ordinal data
#' @param cat_dist_fn distance metric function for categorical data
#' @param mix_dist_fn distance metric function for mixed data
#' @param weights_row dataframe row containing variable weights
#'
#' @return fused_network The final fused network for clustering
#'
#' @export
snf_step <- function(data_list,
                     scheme,
                     k = 20,
                     alpha = 0.5,
                     t = 20,
                     cont_dist_fn,
                     disc_dist_fn,
                     ord_dist_fn,
                     cat_dist_fn,
                     mix_dist_fn,
                     weights_row) {
    # The individual scheme creates similarity matrices for each dl element
    #  and pools them all into a single SNF run
    if (scheme %in% c("individual", 1)) {
        fused_network <- individual(
            data_list,
            cont_dist_fn = cont_dist_fn,
            disc_dist_fn = disc_dist_fn,
            ord_dist_fn = ord_dist_fn,
            cat_dist_fn = cat_dist_fn,
            mix_dist_fn = mix_dist_fn,
            weights_row = weights_row,
            k = k,
            alpha = alpha,
            t = t
        )
    # The domain scheme first runs domain merge on the data list (concatenates
    #  any data of the same domain) and then pools the concatenated data into a
    #  single SNF run
    } else if (scheme %in% c("domain", 2)) {
        fused_network <- domain_merge(
            data_list,
            cont_dist_fn = cont_dist_fn,
            disc_dist_fn = disc_dist_fn,
            ord_dist_fn = ord_dist_fn,
            cat_dist_fn = cat_dist_fn,
            mix_dist_fn = mix_dist_fn,
            weights_row = weights_row,
            k = k,
            alpha = alpha,
            t = t
        )
    # The twostep scheme
    } else if (scheme %in% c("twostep", 3)) {
        fused_network <- two_step_merge(
            data_list,
            k = k,
            alpha = alpha,
            t = t,
            cont_dist_fn = cont_dist_fn,
            disc_dist_fn = disc_dist_fn,
            ord_dist_fn = ord_dist_fn,
            cat_dist_fn = cat_dist_fn,
            mix_dist_fn = mix_dist_fn,
            weights_row = weights_row
        )
    } else {
        rlang::abort(
            paste0("The value '", scheme, "' is not a valid snf scheme."),
            class = "invalid_input")
    }
    return(fused_network)
}

#' Two step SNF
#'
#' @description
#' Individual dataframes into individual similarity matrices into one fused
#'  network per domain into one final fused network.
#'
#' @param data_list nested list of input data generated by the function
#'  `get_data_list()`
#' @param k k hyperparameter
#' @param alpha alpha/eta/sigma hyperparameter
#' @param t SNF number of iterations hyperparameter
#' @param cont_dist_fn distance metric function for continuous data
#' @param disc_dist_fn distance metric function for discrete data
#' @param ord_dist_fn distance metric function for ordinal data
#' @param cat_dist_fn distance metric function for categorical data
#' @param mix_dist_fn distance metric function for mixed data
#' @param weights_row dataframe row containing variable weights
#'
#' @return fused_network The final fused network for clustering
#'
#' @export
two_step_merge <- function(data_list,
                           k = 20,
                           alpha = 0.5,
                           t = 20,
                           cont_dist_fn,
                           disc_dist_fn,
                           ord_dist_fn,
                           cat_dist_fn,
                           mix_dist_fn,
                           weights_row) {
    dist_list <- lapply(
        data_list,
        function(x) {
            get_dist_matrix(
                df = x$"data",
                input_type = x$"type",
                cont_dist_fn = cont_dist_fn,
                disc_dist_fn = disc_dist_fn,
                ord_dist_fn = ord_dist_fn,
                cat_dist_fn = cat_dist_fn,
                mix_dist_fn = mix_dist_fn,
                weights_row = weights_row
            )
        }
    )
    sim_list <- lapply(
        dist_list,
        function(x) {
            SNFtool::affinityMatrix(x, K = k, sigma = alpha)
        }
    )
    affinity_list <- data_list
    for (i in seq_along(affinity_list)) {
        affinity_list[[i]]$"data" <- sim_list[[i]]
    }
    affinity_unique_dl <- list()
    unique_domains <- unique(unlist(domains(affinity_list)))
    for (i in seq_along(unique_domains)) {
        affinity_unique_dl <- append(affinity_unique_dl, list(list()))
    }
    names(affinity_unique_dl) <- unique_domains
    for (i in seq_along(affinity_list)) {
        al_current_domain <- affinity_list[[i]]$"domain"
        al_current_amatrix <- affinity_list[[i]]$"data"
        audl_domain_pos <- which(names(affinity_unique_dl) == al_current_domain)
        affinity_unique_dl[[audl_domain_pos]] <-
            append(affinity_unique_dl[[audl_domain_pos]],
            list(al_current_amatrix))
    }
    # Fusing individual matrices into domain affinity matrices
    step_one <- lapply(affinity_unique_dl,
       function(x) {
           if (length(x) == 1) {
               x[[1]]
           } else {
               SNFtool::SNF(Wall = x, K = k, t = t)
           }
       })
    # Fusing domain affinity matrices into final fused network
    if (length(step_one) > 1) {
        fused_network <- SNFtool::SNF(Wall = step_one, K = k, t = t)
    } else {
        fused_network <- step_one[[1]]
    }
    return(fused_network)
}

#' SNF scheme: Domain merge
#'
#' @description
#' Given a data_list, returns a new data_list where all original data objects of
#'  a particlar domain have been concatenated
#'
#' @param data_list nested list of input data generated by the function
#'  `get_data_list()`
#' @param k k hyperparameter
#' @param alpha alpha/eta/sigma hyperparameter
#' @param t SNF number of iterations hyperparameter
#' @param cont_dist_fn distance metric function for continuous data
#' @param disc_dist_fn distance metric function for discrete data
#' @param ord_dist_fn distance metric function for ordinal data
#' @param cat_dist_fn distance metric function for categorical data
#' @param mix_dist_fn distance metric function for mixed data
#' @param weights_row dataframe row containing variable weights
#'
#' @return fused_network The final fused network for clustering
#'
#' @export
domain_merge <- function(data_list,
                         cont_dist_fn,
                         disc_dist_fn,
                         ord_dist_fn,
                         cat_dist_fn,
                         mix_dist_fn,
                         weights_row,
                         k,
                         alpha,
                         t) {
    #dl_summary <- summarize_dl(data_list)
    #domains <- dl_summary$"domain" |> unique()
    # list to store all the possible values
    merged_dl <- list()
    for (i in seq_along(data_list)) {
        current_domain <- data_list[[i]]$"domain"
        current_data <- data_list[[i]]$"data"
        current_name <- data_list[[i]]$"name"
        current_type <- data_list[[i]]$"type"
        merged_dl_domains <- summarize_dl(merged_dl)$"domain" |> unique()
        if (current_domain %in% merged_dl_domains) {
            # the index of the new data_list that already has the domain of the
            #  ith component of the original data_list
            existing_pos <- which(merged_dl_domains == current_domain)
            existing_component <- merged_dl[[existing_pos]]
            existing_data <- existing_component$"data"
            existing_type <- existing_component$"type"
            new_data <- dplyr::inner_join(
                existing_data,
                current_data,
                by = "subjectkey"
            )
            if (current_type == existing_type) {
                new_type <- existing_type
            } else {
                new_type == "mixed"
            }
            merged_dl[[existing_pos]]$"data" <- new_data
            merged_dl[[existing_pos]]$"type" <- new_type
        } else {
            merged_dl[[length(merged_dl) + 1]] <- data_list[[i]]
        }
    }
    merged_dl <- merged_dl |>
        lapply(
            function(x) {
                x$"name" <- paste0("merged_", x$"domain")
                return(x)
            }
        )
    # now that we have the merged data_list, complete the conversion to
    #  distance and affinity matrices
    dist_list <- lapply(merged_dl,
        function(x) {
            get_dist_matrix(
                df = x$"data",
                input_type = x$"type",
                cont_dist_fn = cont_dist_fn,
                disc_dist_fn = disc_dist_fn,
                ord_dist_fn = ord_dist_fn,
                cat_dist_fn = cat_dist_fn,
                mix_dist_fn = mix_dist_fn,
                weights_row = weights_row
            )
        }
    )
    sim_list <- lapply(
        dist_list,
        function(x) {
            affinity_matrix <- SNFtool::affinityMatrix(x, K = k, sigma = alpha)
            return(affinity_matrix)
        }
    )
    fused_network <- SNFtool::SNF(Wall = sim_list, K = k, t = t)
    return(fused_network)
}

#' SNF Scheme: Individual
#'
#' The "vanilla" scheme - does distance matrix conversions of each input
#'  dataframe in a list and
#'
#' @param data_list nested list of input data generated by the function
#'  `get_data_list()`
#' @param k k hyperparameter
#' @param alpha alpha/eta/sigma hyperparameter
#' @param t SNF number of iterations hyperparameter
#' @param cont_dist_fn distance metric function for continuous data
#' @param disc_dist_fn distance metric function for discrete data
#' @param ord_dist_fn distance metric function for ordinal data
#' @param cat_dist_fn distance metric function for categorical data
#' @param mix_dist_fn distance metric function for mixed data
#' @param weights_row dataframe row containing variable weights
#'
#' @return fused_network The final fused network for clustering
#'
#' @export
individual <- function(data_list,
                       cont_dist_fn,
                       disc_dist_fn,
                       ord_dist_fn,
                       cat_dist_fn,
                       mix_dist_fn,
                       weights_row,
                       k,
                       alpha,
                       t) {
    dist_list <- lapply(
        data_list,
        function(x) {
            get_dist_matrix(
                df = x$"data",
                input_type = x$"type",
                cont_dist_fn = cont_dist_fn,
                disc_dist_fn = disc_dist_fn,
                ord_dist_fn = ord_dist_fn,
                cat_dist_fn = cat_dist_fn,
                mix_dist_fn = mix_dist_fn,
                weights_row = weights_row
            )
        }
    )
    sim_list <- lapply(
        dist_list,
        function(x) {
            SNFtool::affinityMatrix(x, K = k, sigma = alpha)
        }
    )
    fused_network <- SNFtool::SNF(Wall = sim_list, K = k, t = t)
    return(fused_network)
}

#' Run variations of SNF.
#'
#' This is the core function of the metasnf package. Using the information
#' stored in a settings_matrix (see ?generate_settings_matrix) and a data list
#' (see ?data_list), run repeated complete SNF pipelines to generate
#' a broad space of post-SNF cluster solutions.
#'
#' @param dl A nested list of input data from `data_list()`.
#'
#' @param settings_matrix A data.frame where each row completely defines an SNF
#' pipeline transforming individual input dataframes into a final cluster
#' solution. See ?generate_settings_matrix or
#' https://branchlab.github.io/metasnf/articles/settings_matrix.html for more
#' details.
#'
#' @param processes Specify number of processes used to complete SNF iterations
#'  * `1` (default) Sequential processing: function will iterate through the
#'    `settings_matrix` one row at a time with a for loop. This option will
#'     not make use of multiple CPU cores, but will show a progress bar.
#'  * `2` or higher: Parallel processing will use the
#'    `future.apply::future_apply` to distribute the SNF iterations across
#'    the specified number of CPU cores. If higher than the number of
#'    available cores, a warning will be raised and the maximum number of
#'    cores will be used.
#'  * `max`: All available cores will be used.
#'
#' @param return_similarity_matrices If TRUE, function will return a list where
#' the first element is the solutions matrix and the second element is a list
#' of similarity matrices for each row in the solutions_matrix. Default FALSE.
#'
#' @param similarity_matrix_dir If specified, this directory will be used to
#' save all generated similarity matrices.
#'
#' @param clust_algs_list List of custom clustering algorithms to apply
#' to the final fused network. See ?generate_clust_algs_list.
#'
#' @param suppress_clustering If FALSE (default), will apply default or custom
#' clustering algorithms to provide cluster solutions on every iteration of
#' SNF. If TRUE, parameter `similarity_matrix_dir` must be specified.
#'
#' @param dml An optional nested list containing which
#' distance metric function should be used for the various feature types
#' (continuous, discrete, ordinal, categorical, and mixed). See
#' ?distance_metrics_list for details on how to build this.
#'
#' @param weights_matrix A matrix containing feature weights to use during
#' distance matrix calculation. See ?generate_weights_matrix for details on
#' how to build this.
#'
#' @param automatic_standard_normalize If TRUE, will automatically apply
#' standard normalization prior to calculation of any distance matrices. This
#' parameter cannot be used in conjunction with a custom distance metrics list.
#' If you wish to supply custom distance metrics but also always have standard
#' normalization, simply ensure that the numeric (continuous, discrete, and
#' ordinal) distance metrics are only populated with distance metric functions
#' that apply standard normalization. See
#' https://branchlab.github.io/metasnf/articles/distance_metrics.html to learn
#' more.
#'
#' @param verbose If TRUE, output time remaining estimates to console.
#'
#' @return By default, returns a solutions matrix (class "data.frame"), a 
#' a data frame containing one row for every row of the provided settings
#' matrix, all the original columns of that settings matrix, and new columns
#' containing the assigned cluster of each observation from the cluster
#' solution derived by that row's settings. If `return_similarity_matrices` is
#' TRUE, the function will instead return a list containing the
#' solutions matrix as well as a list of the final similarity matrices (class
#' "matrix") generated by SNF for each row of the settings matrix. If 
#' `suppress_clustering` is TRUE, the solutions matrix will not be returned
#' in the output.
#'
#' @export
batch_snf <- function(dl,
                      settings_matrix,
                      processes = 1,
                      return_similarity_matrices = FALSE,
                      similarity_matrix_dir = NULL,
                      clust_algs_list = NULL,
                      suppress_clustering = FALSE,
                      dml = NULL,
                      weights_matrix = NULL,
                      automatic_standard_normalize = FALSE,
                      verbose = FALSE) {
    ###########################################################################
    # 1. Start timer to keep track of entire function duration
    ###########################################################################
    if (verbose) {
        start <- proc.time() # final time taken for entire function
        remaining_seconds_vector <- vector() # estimate time to completion
    }
    ###########################################################################
    # 2. Ensure settings_matrix is a data.frame (not a tibble or matrix)
    ###########################################################################
    settings_matrix <- data.frame(settings_matrix)
    ###########################################################################
    # 3. Check validity of settings
    ###########################################################################
    # The user may have chosen to simultaneously not save similarity matrices
    # and to not apply any clustering algorithms. In that case, this function
    # is not really doing anything. Stop the function with an error.
    no_similarity_matrices <-
        is.null(similarity_matrix_dir) & !return_similarity_matrices
    if (no_similarity_matrices && suppress_clustering) {
        metasnf_error(
            "Setting `suppress_clustering` to `TRUE`,",
            " `similarity_matrix_dir` to `NULL`,",
            " and return_similarity_matrices to `FALSE` yields",
            " no meaningful output."
        )
    }
    # If there is a value of the k hyperparameter that exceeds the number
    # of patients in the data list, SNFtool::affinityMatrix cannot run. This
    # check can't go in the generate_settings_matrix function in case the user
    # creater their base settings_matrix with a valid k, then extended their
    # settings matrix using the add_settings_matrix_rows function with an
    # invalid k (a function that doesn't require users to supply the data).
    max_k <- max(settings_matrix$"k")
    n_patients <- unique(summarize_dl(dl)$"length")
    # Ensure that the maximum k value doesn't exceed the number of subjects
    if (max_k >= n_patients) {
        metasnf_error(
            "The highest value of k in the settings_matrix ({max_k}) ",
            "cannot exceed the number of observations in the data lis",
            "t ({n_patients})."
        )
    }
    ###########################################################################
    # 4. Creation of dml if it does not already exist
    ###########################################################################
    if (is.null(dml)) {
        if (automatic_standard_normalize) {
            # Generate a list with standard normalization
            dml <- distance_metrics_list(
                cnt_dist_fns = list(
                    "sn_euclidean_distance" = sn_euclidean_distance
                ),
                dsc_dist_fns = list(
                    "sn_euclidean_distance" = sn_euclidean_distance
                ),
                ord_dist_fns = list(
                    "sn_euclidean_distance" = sn_euclidean_distance
                ),
                cat_dist_fns = list(
                    "gower_distance" = gower_distance
                ),
                mix_dist_fns = list(
                    "gower_distance" = gower_distance
                ),
                use_defaults = FALSE
            )
        } else {
            dml <- distance_metrics_list(use_defaults = TRUE)
        }
    } else {
        if (automatic_standard_normalize) {
            metasnf_error(
                "`automatic_standard_normalize` cannot be used at the",
                " same time as a custom distance metrics list."
            )
        }
    }
    ###########################################################################
    # 5. Creation of weights_matrix, if it does not already exist
    ###########################################################################
    if (is.null(weights_matrix)) {
        weights_matrix <- generate_weights_matrix(
            dl,
            nrow = nrow(settings_matrix)
        )
    } else {
        if (nrow(weights_matrix) != nrow(settings_matrix)) {
            metasnf_error(
                "weights_matrix and settings_matrix should have the same",
                " number of rows."
            )
        }
    }
    ###########################################################################
    # 6. Creation of clust_algs_list, if it does not already exist
    ###########################################################################
    # If the user has not provided their own list of clustering algorithms,
    #  use the default ones (spectral clustering with eigen-gap or
    #  rotation cost heuristics).
    if (is.null(clust_algs_list)) {
        clust_algs_list <- generate_clust_algs_list()
    }
    ###########################################################################
    # 7. Call separate function for parallel processing
    ###########################################################################
    if (processes != 1) {
        available_cores <- max(future::availableCores())
        # Use all available cores
        if (processes == "max") {
            solutions_matrix <- parallel_batch_snf(
                dl = dl,
                dml = dml,
                clust_algs_list = clust_algs_list,
                settings_matrix = settings_matrix,
                weights_matrix = weights_matrix,
                similarity_matrix_dir = similarity_matrix_dir,
                return_similarity_matrices = return_similarity_matrices,
                processes = available_cores
            )
            return(solutions_matrix)
        } else if (is.numeric(processes)) {
            # Use the user-specified number of cores
            if (processes > available_cores) {
                metasnf_warning(
                    "You specified ", processes, " processes, but only ",
                    available_cores, " cores are available. Defaulting to ",
                    available_cores, " processes."
                )
                processes <- available_cores
            }
            solutions_matrix <- parallel_batch_snf(
                dl = dl,
                dml = dml,
                clust_algs_list = clust_algs_list,
                settings_matrix = settings_matrix,
                weights_matrix = weights_matrix,
                similarity_matrix_dir = similarity_matrix_dir,
                return_similarity_matrices = return_similarity_matrices,
                processes = processes
            )
            return(solutions_matrix)
        } else {
            metasnf_error("Invalid number of processes specified.")
        }
    }
    ###########################################################################
    # 8. Single thread - Create solutions_matrix
    ###########################################################################
    # Creation of solutions_matrix (where clustering results are stored)
    # solutions_matrix is a dataframe with the following columns:
    #  - row_id (1 column): number matching the row of the settings_matrix used
    #    to generate this solution
    #  - inc_* (1 column per input df): Binary indicating if the input df was
    #    incuded (1) or excluded (0) for this row of SNF
    #  - snf_scheme (1 column): number indicating which of the preprogrammed
    #    'schemes' was used to for this run of SNF
    #  - alpha (AKA sigma or eta): value of similarity matrix hyperparameter
    #  - k: value of similarity matrix hyperparameter
    #  - T: Number of iterations of SNF
    #  - uid_* (1 column per patient): cluster membership of that patient
    #    for that row. Only included when run_clustering = TRUE.
    #  - nclust (1 column): number of clusters in the cluster solution in that
    #    row. Only included when run_clustering = TRUE.
    ###########################################################################
    # 5a. solutions_matrix begins as the settings_matrix extended with one new
    #  column for every subjects.
    if (!suppress_clustering) {
        solutions_matrix <- add_columns(
            df = settings_matrix,
            cols = dl[[1]]$"data"$"uid", # one col/patient
            value = 0 # populate the new column with 0s by default
        )
        # 5b. solutions_matrix gets one new column to store the cluster that
        # each subject was assigned to.
        solutions_matrix <- add_columns(
            df = settings_matrix,
            cols = "nclust",
            value = 0
        )
    }
    ###########################################################################
    # 9. Creation of list to store similarity matrices (if requested)
    ###########################################################################
    if (isTRUE(return_similarity_matrices)) {
        similarity_matrices <- list()
    }
    ###########################################################################
    # 10. Iterate through the rows of the settings matrix
    ###########################################################################
    for (i in seq_len(nrow(settings_matrix))) {
        start_time <- Sys.time() # used to estimate time to completion
        settings_matrix_row <- settings_matrix[i, ]
        weights_row <- weights_matrix[i, , drop = FALSE]
        current_dl <- drop_inputs(settings_matrix_row, dl)
        # Apply the current row's SNF scheme
        current_snf_scheme <- dplyr::case_when(
            settings_matrix_row$"snf_scheme" == 1 ~ "individual",
            settings_matrix_row$"snf_scheme" == 2 ~ "domain",
            settings_matrix_row$"snf_scheme" == 3 ~ "twostep",
        )
        k <- settings_matrix_row$"k"
        alpha <- settings_matrix_row$"alpha"
        t <- settings_matrix_row$"t"
        cnt_dist <- settings_matrix_row$"cnt_dist"
        dsc_dist <- settings_matrix_row$"dsc_dist"
        ord_dist <- settings_matrix_row$"ord_dist"
        cat_dist <- settings_matrix_row$"cat_dist"
        mix_dist <- settings_matrix_row$"mix_dist"
        cnt_dist_fn <- dml$"cnt_dist_fns"[[cnt_dist]]
        dsc_dist_fn <- dml$"dsc_dist_fns"[[dsc_dist]]
        ord_dist_fn <- dml$"ord_dist_fns"[[ord_dist]]
        cat_dist_fn <- dml$"cat_dist_fns"[[cat_dist]]
        mix_dist_fn <- dml$"mix_dist_fns"[[mix_dist]]
        # Run SNF
        fused_network <- snf_step(
            current_dl,
            current_snf_scheme,
            k = k,
            alpha = alpha,
            t = t,
            cnt_dist_fn = cnt_dist_fn,
            dsc_dist_fn = dsc_dist_fn,
            ord_dist_fn = ord_dist_fn,
            cat_dist_fn = cat_dist_fn,
            mix_dist_fn = mix_dist_fn,
            weights_row = weights_row
        )
        # If user provided a path to save the similarity matrices, save them
        if (!is.null(similarity_matrix_dir)) {
            utils::write.csv(
                x = fused_network,
                file = similarity_matrix_path(similarity_matrix_dir, i),
                row.names = TRUE
            )
        }
        # If the user requested all similarity matrices are returned, add to list
        if (isTRUE(return_similarity_matrices)) {
            similarity_matrices[[length(similarity_matrices) + 1]] <- fused_network
        }
        #######################################################################
        # 11. Clustering of the final fused network
        #######################################################################
        # clust_alg stores the function to be used for this run of SNF
        clust_alg <- clust_algs_list[[settings_matrix_row$"clust_alg"]]
        # cluster_results is a named list containing the cluster solution
        #  (vector of which cluster each patient was assigned to) and the
        #  number of clusters for that solution
        cluster_results <- clust_alg(fused_network)
        solution <- cluster_results$"solution"
        nclust <- cluster_results$"nclust"
        # Update the solutions_matrix with the cluster solution and the number
        #  of clusters for that solution
        if (!suppress_clustering) {
            solutions_matrix[i, rownames(fused_network)] <- solution
            solutions_matrix[i, "nclust"] <- nclust
        }
        #######################################################################
        # 12. Output progress
        #######################################################################
        if (verbose) {
            cat(
                "Processing row: ", i, "/", nrow(settings_matrix), "\n",
                sep = ""
            )
        }
    }
    ###########################################################################
    # 13. Format the final solutions_matrix to be numeric where possible
    ###########################################################################
    if (!suppress_clustering) {
        solutions_matrix <- numcol_to_numeric(solutions_matrix)
    }
    ###########################################################################
    # 14. Return final output
    ###########################################################################
    # The user requested that similarity matrices are returned. Create a list
    #  containing the solutions matrix as well as the similarity matrices and
    #  return that.
    if (isTRUE(return_similarity_matrices)) {
        check_similarity_matrices(similarity_matrices)
        if (!suppress_clustering) {
            # the user wants similarity matrices and solutions matrix
            batch_snf_results <- list(
                solutions_matrix,
                similarity_matrices
            )
            names(batch_snf_results) <- c(
                "solutions_matrix",
                "similarity_matrices"
            )
            return(batch_snf_results)
        } else {
            # the user wants similarity matrices but no solutions matrix
            return(similarity_matrices)
        }
    } else {
        # The user did not request that similarity matrices are returned. Just
        #  return the solutions matrix. Don't need to check if solutions
        #  matrices are requested - that was handled earlier in the funciton.
        return(solutions_matrix)
    }
}

#' Execute inclusion
#'
#' Given a data list and a settings matrix row, returns a data list of selected
#' inputs
#'
#' @param settings_matrix_row Row of a settings matrix.
#' @param dl A nested list of input data from `data_list()`.
#'
#' @return A data list (class "list") in which any component with a
#' corresponding 0 value in the provided settings matrix row has been removed.
#'
#' @export
drop_inputs <- function(settings_matrix_row, dl) {
    # Dataframe just of the inclusion features
    inc_df <- settings_matrix_row |>
        dplyr::select(dplyr::starts_with("inc"))
    # The subset of columns that are in 'keep' (1) mode
    keepcols <- colnames(inc_df)[inc_df[1, ] == 1]
    # The list of data list elements that are to be selected
    in_keeps_list <- lapply(dl,
        function(x) {
            paste0("inc_", x$"name") %in% keepcols
        }
    ) # Converting to a logical type to do the selection
    in_keeps_log <- c(unlist(in_keeps_list))
    # The selection
    selected_dl <- dl[in_keeps_log]
    reduced_selected_dl <- reduce_dll_to_common(selected_dl)
    return(reduced_selected_dl)
}

#' Calculate distance matrices
#'
#' Given a dataframe of numerical features, return a euclidean distance matrix.
#'
#' @param df Raw dataframe with subject IDs in column "uid"
#'
#' @param input_type Either "numeric" (resulting in euclidean distances),
#' "categorical" (resulting in binary distances), or "mixed" (resulting in
#' gower distances)
#'
#' @param cnt_dist_fn distance metric function for continuous data
#'
#' @param dsc_dist_fn distance metric function for discrete data
#'
#' @param ord_dist_fn distance metric function for ordinal data
#'
#' @param cat_dist_fn distance metric function for categorical data
#'
#' @param mix_dist_fn distance metric function for mixed data
#'
#' @param weights_row Single-row dataframe where the column names contain the
#' column names in df and the row contains the corresponding weights_row.
#'
#' @return dist_matrix Matrix of inter-observation distances.
#'
#' @export
get_dist_matrix <- function(df,
                            input_type,
                            cnt_dist_fn,
                            dsc_dist_fn,
                            ord_dist_fn,
                            cat_dist_fn,
                            mix_dist_fn,
                            weights_row) {
    # Move subject keys into dataframe rownames
    df <- data.frame(df, row.names = "uid")
    # Trim down of the full weights row
    weights_row_trim <-
        weights_row[, colnames(weights_row) %in% colnames(df), drop = FALSE]
    # Use 1 for anything that is not present in weights_row
    missing_weights <-
        df[1, !colnames(df) %in% colnames(weights_row_trim), drop = FALSE]
    missing_weights[, ] <- 1
    weights_row_trim <- cbind(weights_row_trim, missing_weights)
    weights_row_trim <- weights_row_trim[, colnames(df)]
    if (input_type == "continuous") {
        dist_fn <- cnt_dist_fn
    } else if (input_type == "discrete") {
        dist_fn <- dsc_dist_fn
    } else if (input_type == "ordinal") {
        dist_fn <- ord_dist_fn
    } else if (input_type == "categorical") {
        dist_fn <- cat_dist_fn
    } else if (input_type == "mixed") {
        dist_fn <- mix_dist_fn
    } else {
        metasnf_error(
            "The value ", input_type, " is not a valid input type."
        )
    }
    dist_matrix <- dist_fn(df, weights_row_trim)
    return(dist_matrix)
}

#' SNF schemes
#'
#' These functions manage the way in which input data frames are passed into
#' SNF to yield a final fused network.
#'
#' snf_step: Manages which scheme function should be called.
#'
#' individual: The "vanilla" scheme - does distance matrix conversions of each input
#' data frame separately before a single call to SNF fuses them into the final
#' fused network.
#'
#' domain_merge: Given a data list, returns a new data list where all data objects of
#' a particlar domain have been concatenated.
#'
#' two_step_merge: Individual dataframes into individual similarity matrices into one fused
#' network per domain into one final fused network.
#'
#' @param dl A nested list of input data from `data_list()`.
#' @param scheme Which SNF system to use to achieve the final fused network.
#' @param k k hyperparameter.
#' @param alpha alpha/eta/sigma hyperparameter.
#' @param t SNF number of iterations hyperparameter.
#' @param cnt_dist_fn distance metric function for continuous data.
#' @param dsc_dist_fn distance metric function for discrete data.
#' @param ord_dist_fn distance metric function for ordinal data.
#' @param cat_dist_fn distance metric function for categorical data.
#' @param mix_dist_fn distance metric function for mixed data.
#' @param weights_row dataframe row containing feature weights.
#' @name snf_scheme
NULL

#' @rdname snf_scheme
#' @export
snf_step <- function(dl,
                     scheme,
                     k = 20,
                     alpha = 0.5,
                     t = 20,
                     cnt_dist_fn,
                     dsc_dist_fn,
                     ord_dist_fn,
                     cat_dist_fn,
                     mix_dist_fn,
                     weights_row) {
    # The individual scheme creates similarity matrices for each dl element
    # and pools them all into a single SNF run.
    #
    # The domain scheme first runs domain merge on the data list (concatenates
    # any data of the same domain) and then pools the concatenated data into a
    # single SNF run.
    #
    # The twostep scheme
    if (scheme %in% c("individual", 1)) {
        fused_network <- individual(
            dl,
            cnt_dist_fn = cnt_dist_fn,
            dsc_dist_fn = dsc_dist_fn,
            ord_dist_fn = ord_dist_fn,
            cat_dist_fn = cat_dist_fn,
            mix_dist_fn = mix_dist_fn,
            weights_row = weights_row,
            k = k,
            alpha = alpha,
            t = t
        )
    } else if (scheme %in% c("domain", 2)) {
        fused_network <- domain_merge(
            dl,
            cnt_dist_fn = cnt_dist_fn,
            dsc_dist_fn = dsc_dist_fn,
            ord_dist_fn = ord_dist_fn,
            cat_dist_fn = cat_dist_fn,
            mix_dist_fn = mix_dist_fn,
            weights_row = weights_row,
            k = k,
            alpha = alpha,
            t = t
        )
    } else if (scheme %in% c("twostep", 3)) {
        fused_network <- two_step_merge(
            dl,
            k = k,
            alpha = alpha,
            t = t,
            cnt_dist_fn = cnt_dist_fn,
            dsc_dist_fn = dsc_dist_fn,
            ord_dist_fn = ord_dist_fn,
            cat_dist_fn = cat_dist_fn,
            mix_dist_fn = mix_dist_fn,
            weights_row = weights_row
        )
    } else {
        metasnf_error(
            "The value '", scheme, "' is not a valid snf scheme."
        )
    }
    return(fused_network)
}

#' @rdname snf_scheme
#' @export
two_step_merge <- function(dl,
                           k = 20,
                           alpha = 0.5,
                           t = 20,
                           cnt_dist_fn,
                           dsc_dist_fn,
                           ord_dist_fn,
                           cat_dist_fn,
                           mix_dist_fn,
                           weights_row) {
    dist_list <- lapply(
        dl,
        function(x) {
            get_dist_matrix(
                df = x$"data",
                input_type = x$"type",
                cnt_dist_fn = cnt_dist_fn,
                dsc_dist_fn = dsc_dist_fn,
                ord_dist_fn = ord_dist_fn,
                cat_dist_fn = cat_dist_fn,
                mix_dist_fn = mix_dist_fn,
                weights_row = weights_row
            )
        }
    )
    sim_list <- lapply(
        dist_list,
        function(x) {
            SNFtool::affinityMatrix(x, K = k, sigma = alpha)
        }
    )
    similarity_list <- dl
    for (i in seq_along(similarity_list)) {
        similarity_list[[i]]$"data" <- sim_list[[i]]
    }
    similarity_unique_dl <- list()
    unique_domains <- unique(unlist(domains(similarity_list)))
    for (i in seq_along(unique_domains)) {
        similarity_unique_dl <- append(similarity_unique_dl, list(list()))
    }
    names(similarity_unique_dl) <- unique_domains
    for (i in seq_along(similarity_list)) {
        al_current_domain <- similarity_list[[i]]$"domain"
        al_current_amatrix <- similarity_list[[i]]$"data"
        audl_domain_pos <- which(
            names(similarity_unique_dl) == al_current_domain
        )
        similarity_unique_dl[[audl_domain_pos]] <- append(
            similarity_unique_dl[[audl_domain_pos]],
            list(al_current_amatrix)
        )
    }
    # Fusing individual matrices into domain similarity matrices
    step_one <- lapply(
        similarity_unique_dl,
        function(x) {
            if (length(x) == 1) {
                x[[1]]
            } else {
                SNFtool::SNF(Wall = x, K = k, t = t)
            }
        }
    )
    # Fusing domain similarity matrices into final fused network
    if (length(step_one) > 1) {
        fused_network <- SNFtool::SNF(Wall = step_one, K = k, t = t)
    } else {
        fused_network <- step_one[[1]]
    }
    return(fused_network)
}

#' @rdname snf_scheme
#' @export
domain_merge <- function(dl,
                         cnt_dist_fn,
                         dsc_dist_fn,
                         ord_dist_fn,
                         cat_dist_fn,
                         mix_dist_fn,
                         weights_row,
                         k,
                         alpha,
                         t) {
    # list to store all the possible values
    merged_dl <- list()
    for (i in seq_along(dl)) {
        current_domain <- dl[[i]]$"domain"
        current_data <- dl[[i]]$"data"
        current_type <- dl[[i]]$"type"
        merged_dl_domains <- summarize_dl(merged_dl)$"domain" |> unique()
        if (current_domain %in% merged_dl_domains) {
            # the index of the new data list that already has the domain of the
            #  ith component of the original data list
            existing_pos <- which(merged_dl_domains == current_domain)
            existing_component <- merged_dl[[existing_pos]]
            existing_data <- existing_component$"data"
            existing_type <- existing_component$"type"
            new_data <- dplyr::inner_join(
                existing_data,
                current_data,
                by = "uid"
            )
            if (current_type == existing_type) {
                new_type <- existing_type
            } else {
                new_type <- "mixed"
            }
            merged_dl[[existing_pos]]$"data" <- new_data
            merged_dl[[existing_pos]]$"type" <- new_type
        } else {
            merged_dl[[length(merged_dl) + 1]] <- dl[[i]]
        }
    }
    merged_dl <- merged_dl |>
        lapply(
            function(x) {
                x$"name" <- paste0("merged_", x$"domain")
                return(x)
            }
        )
    # now that we have the merged data list, complete the conversion to
    #  distance and similarity matrices
    dist_list <- lapply(merged_dl,
        function(x) {
            get_dist_matrix(
                df = x$"data",
                input_type = x$"type",
                cnt_dist_fn = cnt_dist_fn,
                dsc_dist_fn = dsc_dist_fn,
                ord_dist_fn = ord_dist_fn,
                cat_dist_fn = cat_dist_fn,
                mix_dist_fn = mix_dist_fn,
                weights_row = weights_row
            )
        }
    )
    sim_list <- lapply(
        dist_list,
        function(x) {
            similarity_matrix <- SNFtool::affinityMatrix(
                x,
                K = k,
                sigma = alpha
            )
            return(similarity_matrix)
        }
    )
    if (length(sim_list) > 1) {
        fused_network <- SNFtool::SNF(Wall = sim_list, K = k, t = t)
    } else {
        fused_network <- sim_list[[1]]
    }
    return(fused_network)
}

#' @rdname snf_scheme
#' @export
individual <- function(dl,
                       k = 20,
                       alpha = 0.5,
                       t = 20,
                       cnt_dist_fn,
                       dsc_dist_fn,
                       ord_dist_fn,
                       cat_dist_fn,
                       mix_dist_fn,
                       weights_row) {
    dist_list <- lapply(
        dl,
        function(x) {
            get_dist_matrix(
                df = x$"data",
                input_type = x$"type",
                cnt_dist_fn = cnt_dist_fn,
                dsc_dist_fn = dsc_dist_fn,
                ord_dist_fn = ord_dist_fn,
                cat_dist_fn = cat_dist_fn,
                mix_dist_fn = mix_dist_fn,
                weights_row = weights_row
            )
        }
    )
    sim_list <- lapply(
        dist_list,
        function(x) {
            SNFtool::affinityMatrix(x, K = k, sigma = alpha)
        }
    )
    # If only a single similarity matrix is in the sim_list, no need for SNF
    if (length(sim_list) > 1) {
        fused_network <- SNFtool::SNF(Wall = sim_list, K = k, t = t)
    } else {
        fused_network <- sim_list[[1]]
    }
    return(fused_network)
}

#' Parallel processing form of batch_snf
#'
#' @param data_list nested list of input data generated by the function
#'  `get_data_list()`
#' @param settings_matrix matrix indicating parameters to iterate SNF through
#' @param processes Number of parallel processes used when executing SNF
#'
#' @return populated_settings_matrix settings matrix with filled columns related to
#'  subtype membership
#'
#' @export
parallel_batch_snf <- function(data_list,
                               settings_matrix,
                               processes) {
    print(
        paste0(
            "Utilizing ", processes, " processes. Real time progress is not",
            " available during parallel processing."
        )
    )
    start <- proc.time()
    future::plan(future::multisession, workers = processes)
    settings_matrix <- data.frame(settings_matrix)
    solutions_matrix <- future.apply::future_apply(
        settings_matrix,
        1,
        settings_matrix_row_fn,
        dl = data_list
    )
    solutions_matrix <- do.call("rbind", solutions_matrix)
    solutions_matrix <- solutions_matrix |>
        unique()
    solutions_matrix <- numcol_to_numeric(solutions_matrix)
    future::plan(future::sequential)
    total_time <- (proc.time() - start)[["elapsed"]]
    print(
        paste0(
            "Total time taken: ", total_time, " seconds."
        )
    )
    return(solutions_matrix)
}

#' Apply-based function for batch_snf
#'
#' @param settings_matrix_row a row of a settings matrix
#' @param dl a data list
#'
#' @return solutions_matrix_row the corresponding solutions_matrix row
#'
#' @export
settings_matrix_row_fn <- function(settings_matrix_row, dl) {
    settings_matrix_row <- data.frame(t(settings_matrix_row))
    current_data_list <- drop_inputs(settings_matrix_row, dl)
    current_snf_scheme <- dplyr::case_when(
        settings_matrix_row$"snf_scheme" == 1 ~ "individual",
        settings_matrix_row$"snf_scheme" == 2 ~ "domain",
        settings_matrix_row$"snf_scheme" == 3 ~ "twostep",
    )
    k <- settings_matrix_row$"k"
    alpha <- settings_matrix_row$"alpha"
    fused_network <- snf_step(
        current_data_list,
        current_snf_scheme,
        k = k,
        alpha = alpha)
    all_clust <- SNFtool::estimateNumberOfClustersGivenGraph(fused_network)
    # Apply the current row's number of clusters heuristic
    if (settings_matrix_row$"eigen_or_rot" == 1) {
        eigen_best <- all_clust$`Eigen-gap best`
        nclust <- eigen_best
    } else if (settings_matrix_row$"eigen_or_rot" == 2) {
        rot_best <- all_clust$`Rotation cost best`
        nclust <- rot_best
    }
    settings_matrix_row$"nclust" <- nclust
    cluster_results <- SNFtool::spectralClustering(fused_network, nclust)
    # Assign subtype membership
    settings_matrix_row[1, rownames(fused_network)] <- cluster_results
    return(settings_matrix_row)
}



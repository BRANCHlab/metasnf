# Given a dataframe of numerical variables, return a euclidean distance matrix
get_dist_matrix <- function(abcd_df, input_type) {
    # Move subject keys into dataframe rownames
    abcd_df <- data.frame(abcd_df, row.names = 1)
    if (input_type == "numeric") {
        dist_matrix <- as.matrix(stats::dist(abcd_df, method = "euclidean"))
    }
    return(dist_matrix)
}

get_sim_matrix <- function(abcd_df, input_type) {
    dist_matrix <- get_dist_matrix(abcd_df, input_type)
    sim_matrix <- SNFtool::affinityMatrix(dist_matrix)
    return(sim_matrix)
}

# Given list of similarity matrices, return fused network
snf <- function() {
    return(NULL)
}

# Given measurement types, their subdomains, and their domains
snf_step <- function() {
    return(NULL)
}

# Given fused network, return cluster membership of patients
spectral_clustering <- function() {
    return(NULL)
}

# Given clustered subjects and outcome measures, evaluate clustering utility
evaluate_clustering <- function() {
    return(NULL)
}


#' Construct the base of the design matrix
#'
#' @return design_matrix A skeleton dataframe to build a design matrix out of
#'
#' @export
build_design_matrix_base <- function() {
    design_matrix <- data.frame(
        inc_mtbi_loc = numeric(),
        inc_mtbi_mechanism = numeric(),
        inc_mtbi_mem_daze = numeric(),
        inc_income = numeric(),
        inc_interview_age = numeric(),
        inc_mtbi_age = numeric(),
        inc_pubertal_status = numeric(),
        inc_race_cd = numeric(),
        inc_race_ed = numeric(),
        inc_sex = numeric(),
        inc_wmndf = numeric(),
        inc_headaches = numeric(),
        inc_mtbi_count = numeric(),
        inc_gord_cor = numeric(),
        inc_gord_var = numeric(),
        inc_subc_cor = numeric(),
        inc_subc_var = numeric(),
        inc_cort_sa = numeric(),
        inc_cort_t = numeric(),
        inc_subc_v = numeric(),
        stringsAsFactors = FALSE)
    return(design_matrix)
}

#' Generate random sequence for column exclusions component of design matrix
#'
#' Helper function to contribute to rows within the design matrix.
#' Number of columns removed follows the exponential probability distribution
#' to typically keep all or most columns.
#'
#' @param num_cols Number of feature columns in consideration for exclusion
#'
#' @return shuffled_removals Binary vector sequence indicating if a column
#' should be included (1) or excluded (0)
#'
#' @export
random_removal <- function(num_cols) {
    rand_vals <- stats::rexp(10000)
    rand_vals <- rand_vals / max(rand_vals) * num_cols
    rand_vals <- floor(rand_vals)
    num_removed <- sample(rand_vals, 1)
    remove_placeholders <- rep(0, num_removed)
    keep_placeholders <- rep(1, num_cols - num_removed)
    unshuffled_removals <- c(remove_placeholders, keep_placeholders)
    shuffled_removals <- sample(unshuffled_removals)
    return(shuffled_removals)
}

#' Add and populate rows to an existing design matrix
#'
#' @param design_matrix The existing design matrix
#' @param nrows The number of rows to be added to the design matrix
#'
#' @return design_matrix New design matrix containing additional rows
#'
#' @export
add_design_matrix_rows <- function(design_matrix, nrows) {
    for (n in 1:nrows) {
        new_row <- vector()
        num_inclusion_cols <- sum(startsWith(colnames(design_matrix), "inc"))
        new_row <- random_removal(num_inclusion_cols)
        new_row <- t(data.frame(new_row))
        colnames(new_row) <- colnames(design_matrix)
        design_matrix <- rbind(design_matrix, t(t(data.frame(new_row))))
        print(paste0("Adding row...", as.character(n)))
    }
    return(design_matrix)
}


#' Execute variations of SNF as described by a design matrix
#'
#' @param design_matrix Design matrix
#'     * as built by fns `build_design_matrix_base` and `add_design_matrix_rows`
#' @param mtbi_loc mtbi_loc dataframe generated by `get_*` fns
#' @param mtbi_mechanism mtbi_mechanisc dataframe generated by `get_*` fns
#' @param mtbi_mem_daze mtbi_mem_dazc dataframe generated by `get_*` fns
#' @param income incomc dataframe generated by `get_*` fns
#' @param interview_age interview_agc dataframe generated by `get_*` fns
#' @param mtbi_age mtbi_agc dataframe generated by `get_*` fns
#' @param pubertal_status pubertal_statuc dataframe generated by `get_*` fns
#' @param race race_cc dataframe generated by `get_*` fns
#' @param sex sec dataframe generated by `get_*` fns
#' @param wmndf wmndc dataframe generated by `get_*` fns
#' @param headaches headachec dataframe generated by `get_*` fns
#' @param mtbi_count mtbi_counc dataframe generated by `get_*` fns
#' @param gord_cor gord_coc dataframe generated by `get_*` fns
#' @param gord_var gord_vac dataframe generated by `get_*` fns
#' @param subc_cor subc_coc dataframe generated by `get_*` fns
#' @param subc_var subc_vac dataframe generated by `get_*` fns
#' @param cort_sa cort_sc dataframe generated by `get_*` fns
#' @param cort_t cort_c dataframe generated by `get_*` fns
#' @param subc_v subc_c dataframe generated by `get_*` fns
#'
#' @return design_matrix_executed Design matrix with populated subtype
#' membership and target variable columns
#'
#' @export
execute_design_matrix <- function(design_matrix,
                                  mtbi_loc = NULL,
                                  mtbi_mechanism = NULL,
                                  mtbi_mem_daze = NULL,
                                  income = NULL,
                                  interview_age = NULL,
                                  mtbi_age = NULL,
                                  pubertal_status = NULL,
                                  race = NULL,
                                  sex = NULL,
                                  wmndf = NULL,
                                  headaches = NULL,
                                  mtbi_count = NULL,
                                  gord_cor = NULL,
                                  gord_var = NULL,
                                  subc_cor = NULL,
                                  subc_var = NULL,
                                  cort_sa = NULL,
                                  cort_t = NULL,
                                  subc_v = NULL) {
    # object, object name, subdomain, domain, type
    mtbi_loc_list <-
        list(mtbi_loc, "mtbi_loc", "none", "as", "categorical")
    mtbi_mechanism_list <-
        list(mtbi_mechanism, "mtbi_mechanism", "none", "as", "categorical")
    mtbi_mem_daze_list <-
        list(mtbi_mem_daze, "mtbi_mem_daze", "none", "as", "categorical")
    income_list <-
        list(income, "income", "none", "d", "numerical")
    interview_age_list <-
        list(interview_age, "interview_age", "none", "d", "numerical")
    mtbi_age_list <-
        list(mtbi_age, "mtbi_age", "none", "d", "numerical")
    pubertal_status_list <-
        list(pubertal_status, "pubertal_status", "none", "d", "numerical")
    race_list <-
        list(race, "race", "none", "d", "categorical")
    sex_list <-
        list(sex, "sex", "none", "d", "categorical")
    headaches_list <-
        list(headaches, "headaches", "none", "mh", "categorical")
    mtbi_count_list <-
        list(mtbi_count, "mtbi_count", "none", "mh", "numerical")
    wmndf_list <-
        list(wmndf, "wmndf", "dmri", "n", "numerical")
    gord_cor_list <-
        list(gord_cor, "gord_cor", "rsfmri", "n", "numerical")
    gord_var_list <-
        list(gord_var, "gord_var", "rsfmri", "n", "numerical")
    subc_cor_list <-
        list(subc_cor, "subc_cor", "rsfmri", "n", "numerical")
    subc_var_list <-
        list(subc_var, "subc_var", "rsfmri", "n", "numerical")
    cort_sa_list <-
        list(cort_sa, "cort_sa", "smri", "n", "numerical")
    cort_t_list <-
        list(cort_t, "cort_t", "smri", "n", "numerical")
    subc_v_list <-
        list(subc_v, "subc_v", "smri", "n", "numerical")

    design_matrix_executed <- design_matrix
    scheme <- "individual"
    # Nested list construction to be used for design matrix processing
    # full_list >
    #     measurement type lists >
    #         measurement type, name, domain, variable type

    if (scheme == "individual") {
    }
    # build design matrix rows
    # for each option, randomly select a value
    # check if that vector of options has been done before
    # feed those options into SNF
  # execute design matrix rows
  # update design matrix output columns
  return(NULL)
}

visualize_design_matrix <- function() {
  return(NULL)
}

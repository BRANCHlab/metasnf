#' Extract representative solutions from a matrix of ARIs
#'
#' Following clustering with `batch_snf`, a matrix of pairwise ARIs that show
#' how related each cluster solution is to each other can be generated by the
#' `calc_aris` function. Partitioning of the ARI matrix can be done by
#' visual inspection of `meta_cluster_heatmap()` results or by
#' `shiny_annotator`. Given the indices of meta cluster boundaries, this
#' function will return a single representative solution from each meta cluster
#' based on maximum average ARI to all other solutions within that meta
#' cluster.
#'
#' @param aris Matrix of adjusted rand indices from `calc_aris()`
#' @param split_vector A vector of partition indices.
#' @param order Numeric vector indicating row ordering of solutions data frame.
#' @param sol_df Output of `batch_snf` containing cluster solutions.
#' @param filter_fn Optional function to filter the meta-cluster by prior to
#'  maximum average ARI determination. This can be useful if you are explicitly
#'  trying to select a solution that meets a certain condition, such as only
#'  picking from the 4 cluster solutions within a meta cluster. An example
#'  valid function could be `fn <- function(x) x[x$"nclust" == 4, ]`.
#' @return The provided solutions data frame reduced to just one row per meta
#'  cluster defined by the split vector.
#' @export
get_representative_solutions <- function(aris,
                                         split_vector,
                                         order = NULL,
                                         sol_df,
                                         filter_fn = NULL) {
    #if (is.null(order)) {
    #    order <- seq_len(nrow(sol_df))
    #}
    ###########################################################################
    # Re-sort the solutions data frame based on the aris
    ###########################################################################
    order <- unlist(order)
    aris <- data.frame(aris[order, order])
    sol_df <- sol_df[order, ]
    ###########################################################################
    # Extract and assign meta cluster labels
    ###########################################################################
    mc_labels <- label_splits(split_vector, nrow(sol_df))
    mcs <- unique(mc_labels)
    sol_df$"label" <- mc_labels
    aris$"label" <- mc_labels
    ###########################################################################
    # Iterate through the meta clusters and keep the representative solution
    ###########################################################################
    rep_solutions <- data.frame()
    for (mc in mcs) {
        # Subset to just those solutions and ARIs within the MC
        mc_sm <- sol_df[sol_df$"label" == mc, ]
        mc_ari <- aris[aris$"label" == mc, ]
        mc_ari$"label" <- NULL
        # The most representative solution based on total ARI within MC
        mc_sm$"total_aris" <- rowSums(mc_ari)
        if (!is.null(filter_fn)) {
            mc_sm <- filter_fn(mc_sm)
        }
        rep_mc <- which(mc_sm$"total_aris" == max(mc_sm$"total_aris"))[1]
        rep_solution <- mc_sm[rep_mc, ]
        rep_solution$"total_aris" <- NULL
        rep_solutions <- rbind(rep_solutions, rep_solution)
    }
    ###########################################################################
    # Assign labels to the representative solutions
    ###########################################################################
    return(rep_solutions)
}

get_representative_solutions2 <- function(aris,
                                          split_vector,
                                          order = NULL,
                                          sol_df,
                                          filter_fn = NULL) {
    #if (is.null(order)) {
    #    order <- seq_len(nrow(sol_df))
    #}
    ############################################################################
    ## Re-sort the solutions data frame based on the aris
    ############################################################################
    #order <- unlist(order)
    aris <- data.frame(aris)
    #sol_df <- sol_df[order, ]
    ############################################################################
    ## Extract and assign meta cluster labels
    ############################################################################
    #mc_labels <- label_splits(split_vector, nrow(sol_df))
    #mcs <- unique(mc_labels)
    #sol_df$"label" <- mc_labels
    aris$"mc" <- sol_df$"mc"
    mcs <- unique(sol_df$"mc")
    ###########################################################################
    # Iterate through the meta clusters and keep the representative solution
    ###########################################################################
    rep_solutions <- data.frame()
    for (mc in mcs) {
        # Subset to just those solutions and ARIs within the MC
        mc_sm <- sol_df[sol_df$"mc" == mc, ]
        mc_ari <- aris[aris$"mc" == mc, ]
        mc_ari$"mc" <- NULL
        # The most representative solution based on total ARI within MC
        mc_sm$"total_aris" <- rowSums(mc_ari)
        if (!is.null(filter_fn)) {
            mc_sm <- filter_fn(mc_sm)
        }
        rep_mc <- which(mc_sm$"total_aris" == max(mc_sm$"total_aris"))[1]
        rep_solution <- mc_sm[rep_mc, ]
        rep_solution$"total_aris" <- NULL
        rep_solutions <- rbind(rep_solutions, rep_solution)
    }
    ###########################################################################
    # Assign mcs to the representative solutions
    ###########################################################################
    rep_solutions <- rep_solutions |>
        dplyr::arrange(mc)
    return(rep_solutions)
}
